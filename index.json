[{"categories":["problem","java","reproduce"],"content":"Java导出Excel复盘 在一个项目中，需要实现从数据库拿到数据，最后生成Excel文件返回到前台； 在此期间遇到的问题有： 返回前台，文件名称指定无效 如何 将数据转换到Excel格式 Excel表格结构问题 map放到List中，map.cleaer后，list数据消失问题 –\u003e 克隆Map的方式 如何输出当前时间的方式 整体而言，其中最大的问题就是：如何指定Excel的格式问题，不过记录形式，还是按照逻辑顺序写； ","date":"2021-08-10","objectID":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/:1:0","tags":["jAVA","problem","reproduce"],"title":"”Java导出Excel复盘\"","uri":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/"},{"categories":["problem","java","reproduce"],"content":"数据转换到Excel形式 使用EasyPoi包，这个包是在POI的基础上二次封装的，简化了操作的方式；使用的方式有两种 简单形式的Excle使用注解方式 使用模板，自定义Excel样式； 两种的方法不同，但是都是通过List和Map来实现数据和Excel之间的转换的。主要数据内容实体是放在List中。最后使用提供的类方法直接转换到Excel文件； 起初使用的是Excel,但是只能使用包内内置的集中格式，但是满足不了需求；使用内置的样式主要时使用注解； 属性 类型 默认值 功能 name String null 列名,支持name_id needMerge boolean fasle 是否需要纵向合并单元格(用于含有list中,单个的单元格,合并list创建的多个row) orderNum String “0” 列的排序,支持name_id replace String[] {} 值得替换 导出是{a_id,b_id} 导入反过来 savePath String “upload” 导入文件保存路径,如果是图片可以填写,默认是upload/className/ IconEntity这个类对应的就是upload/Icon/ type int 1 导出类型 1 是文本 2 是图片,3 是函数,10 是数字 默认是文本 width double 10 列宽 height double 10 列高,后期打算统一使用@ExcelTarget的height,这个会被废弃,注意 isStatistics boolean fasle 自动统计数据,在追加一行统计,把所有数据都和输出[这个处理会吞没异常,请注意这一点] isHyperlink boolean false 超链接,如果是需要实现接口返回对象 isImportField boolean true 校验字段,看看这个字段是不是导入的Excel中有,如果没有说明是错误的Excel,读取失败,支持name_id exportFormat String “” 导出的时间格式,以这个是否为空来判断是否需要格式化日期 importFormat String “” 导入的时间格式,以这个是否为空来判断是否需要格式化日期 format String “” 时间格式,相当于同时设置了exportFormat 和 importFormat databaseFormat String “yyyyMMddHHmmss” 导出时间设置,如果字段是Date类型则不需要设置 数据库如果是string 类型,这个需要设置这个数据库格式,用以转换时间格式输出 numFormat String “” 数字格式化,参数是Pattern,使用的对象是DecimalFormat imageType int 1 导出类型 1 从file读取 2 是从数据库中读取 默认是文件 同样导入也是一样的 suffix String “” 文字后缀,如% 90 变成90% isWrap boolean true 是否换行 即支持\\n mergeRely int[] {} 合并单元格依赖关系,比如第二列合并是基于第一列 则{0}就可以了 mergeVertical boolean fasle 纵向合并内容相同的单元格 fixedIndex int -1 对应excel的列,忽略名字 isColumnHidden boolean false 导出隐藏列 以上注解放在实体类上，位置是在字段的上方。 注解 实体类： package com.exampl.news; import cn.afterturn.easypoi.excel.annotation.Excel; /** * Created by JueYue on 2017/8/25. */ public class OneTest { @Excel(name = \"姓名\") String name; @Excel(name = \"年龄\") int age; @Excel(name = \"学号\") String id; public OneTest(String name, int age, String id) { this.name = name; this.age = age; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getId() { return id; } public void setId(String id) { this.id = id; } } 使用 直接将实体的实例化对象放到List列表中，最后使用包内提供的导出类，直接导出为Workbook形式的对象； 输出到文件 package com.exampl.news; import cn.afterturn.easypoi.excel.ExcelExportUtil; import cn.afterturn.easypoi.excel.entity.ExportParams; import cn.afterturn.easypoi.excel.entity.params.ExcelExportEntity; import com.exampl.news.entity.excel.AttributesTotalEntity; import org.apache.poi.ss.usermodel.Workbook; import java.io.*; import java.util.ArrayList; import java.util.List; /** * @author ymyguang * @date 8/10/2021 4:34 PM */ public class TestMain { public static void main(String[] args) throws IOException { List\u003cOneTest\u003e list = new ArrayList\u003cOneTest\u003e(); for (int i = 0; i \u003c 3; i++) { list.add(new OneTest(\"学生\" + i,i + 12,\"BD\" + i)); } Workbook workbook = ExcelExportUtil.exportExcel(new ExportParams(\"TitleName\",\"sheet1\"), OneTest.class, list); FileOutputStream out = new FileOutputStream(\"C:\\\\Users\\\\admin.000\\\\Desktop\\\\web\\\\demo.xls\"); workbook.write(out); out.close(); } } 模板方式（表结构问题） 模板，前提是配置好一个xls文件，其中表内字段有指定的代表方式。这里有一个简单的规则： {{$fe: maplist t t.id }} 解释说明一下 {{}}代表标签边界 fe 代表是，使用的fe的写法 maplist Java代码中，存放整个表格内容map变量名称 t 单个数据元素 t.id 一行数据中，是由map构成，id 就是Map的key,要求填入的就是对应的Value； 几点说明： 整个Excel的内容是存放到hashMap当中的。 主要数据内容，存放到List列表当中，最后存放map对象中，这里的键需要跟标签中的:后面的名称相同。这里是maplist，也就是Java中的map必须包含名为,maplist的键；list集合就是他的值 list集合中的元素是map，map的键需要和标签中的t.xx的xx同名； 演示 模板文件配置: 代码配置 public void fe_map() throws Exception { TemplateExportParams params = new TemplateExportParams( \"WEB-INF/doc/专项支出用款申请书_map.xls\"); Map\u003cString, Object\u003e map = new HashMap\u003cString, Object\u003e(); map.put(\"date\", \"2014-12-25\"); map.put(\"money\", 2000000.00); map.put(\"upperMoney\", \"贰佰万\"); map.put(\"company\", \"执笔潜行科技有限公司\"); map.put(\"bureau\", \"财政局\"); map.put(\"person\", \"JueYue\"); map.put(\"phone\", \"1879740****\"); List\u003cMap\u003cString, String\u003e\u003e listMap = new ArrayList\u003cMap\u003cString, String\u003e\u003e(); for (int i = 0; i \u003c 4; i++) { Map\u003cString, String\u003e lm = new HashMap\u003cString, String\u003e(); lm.put(\"id\", i + 1 + \"\"); lm.put(\"","date":"2021-08-10","objectID":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/:1:1","tags":["jAVA","problem","reproduce"],"title":"”Java导出Excel复盘\"","uri":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/"},{"categories":["problem","java","reproduce"],"content":"返回前端文件名有误问题 前端下载文件，文件名取决于后端中对头部字段的设置； 设置的内容有： 字符产编码格式 内容格式 内容描述（文件名称就在这里） 在Content-Disposition,指定文件名称，但是此前是无效的，通过查找得到以下解决方式 对需要设置的文件名，进行URL编码，将编码之后的内容返回到前台，即可解决； URLEncoder.encode(fileName,“UTF-8”) response.setCharacterEncoding(\"UTF-8\"); response.setHeader(\"content-Type\", \"application/vnd.ms-excel\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName,\"UTF-8\")); ","date":"2021-08-10","objectID":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/:1:2","tags":["jAVA","problem","reproduce"],"title":"”Java导出Excel复盘\"","uri":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/"},{"categories":["problem","java","reproduce"],"content":"map放到List中，map.cleaer后，list数据消失问题 此问题导致的原因是，map被add到List中，仅存放的是地址，因此当map.clear()执行后，地址位置没有对应的内容，因此为空；解决方式也很容易想到：clone当前map,因此下面实际中clone map的几种方式,，具体方式详见代码；以下方式均是浅拷贝 package com.exampl.news; import org.junit.jupiter.api.Test; import java.util.HashMap; import java.util.Map; public class OneTest { @Test public void test() { Map\u003cString, String\u003e map = new HashMap\u003c\u003e(); Map\u003cString, String\u003e map2 = new HashMap\u003c\u003e(); map.put(\"id\", \"1\"); System.out.println(\"原始Map:\" + map.get(\"id\")); // 浅拷贝： // clone拷贝 // Map map2 = (Map) ((HashMap\u003c?, ?\u003e) map).clone(); // 初始化拷贝 // Map map2 = new HashMap(map); // 赋值拷贝 // Map map2 = new HashMap(); // map2.putAll(map); // Set实体传入 // Map\u003cString, String\u003e map2 = new HashMap(); // Set\u003cMap.Entry\u003cString, String\u003e\u003e set = map.entrySet(); // for (Map.Entry\u003cString, String\u003e mapEntry : set) { // map2.put(mapEntry.getKey(), mapEntry.getValue()); // } map.put(\"id\", \"22\"); System.out.println(\"当前Map:\" + map.get(\"id\")); System.out.println(\"克隆Map:\" + map2.get(\"id\")); } } ","date":"2021-08-10","objectID":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/:1:3","tags":["jAVA","problem","reproduce"],"title":"”Java导出Excel复盘\"","uri":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/"},{"categories":["problem","java","reproduce"],"content":"获取当前时间 Calendar c = new GregorianCalendar(); c.setTime(new Date()); SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\"); formatter.format(c,getTime()); ","date":"2021-08-10","objectID":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/:1:4","tags":["jAVA","problem","reproduce"],"title":"”Java导出Excel复盘\"","uri":"/posts/think/java%E5%AF%BC%E5%87%BAexcel%E5%A4%8D%E7%9B%98/"},{"categories":["","",""],"content":"Swagger、Springfox之间的关系 一、Swagger是什么 ","date":"2021-08-07","objectID":"/posts/java/swaggerspringfox%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:0:0","tags":["","",""],"title":"","uri":"/posts/java/swaggerspringfox%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["","",""],"content":"JAVA I/O 元类 InputStream：Java中最基本的输入流，输入形式是字节 OutStream：Java中最基本的输出流，输出形式是字节 Reader：输入形式是字符。字符可以指定 Writer：输出形式字符，字符格式可以指定 常用类 BufferedInputStream BufferedOuputSteam BufferedInputStreamReader：提供字节转字符的转接桥 BufferedOutputStreamReader：输出字节转输出字符的转接桥 Buffered是为了提高效率，在内存中开辟一个缓存空间，读满当前缓冲的大小或者是读完当前文件后才将数据发送给Java文件处理程序； 以下是两者效率粗略的对比代码： import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.util.Calendar; /** * @another ymyguang * @date 8/4/2021 9:59 PM */ public class BufferedTest { public static void main(String[] args) throws IOException { long start,end; File filepath = new File(\"C:\\\\Users\\\\admin.000\\\\Desktop\\\\22.txt\"); FileInputStream fileInputStream11 = new FileInputStream(filepath); // start = Calendar.getInstance().getTimeInMillis(); // while(fileInputStream11.available() \u003e 0) // fileInputStream11.read(); // end = Calendar.getInstance().getTimeInMillis(); //// System.out.println(\"非Buffered时间差为：\" + (end - start) + \"\\n ==========================================\"); start = Calendar.getInstance().getTimeInMillis(); FileInputStream fileInputStream = new FileInputStream(filepath); while(fileInputStream.available() \u003e 0) fileInputStream.read(); end = Calendar.getInstance().getTimeInMillis(); System.out.println(\"非Buffered时间差为：\" + (end - start) + \"\\n ==========================================\"); start = Calendar.getInstance().getTimeInMillis(); BufferedInputStream br = new BufferedInputStream(new FileInputStream(filepath)); while(br.available() \u003e 0) { br.read(); } end = Calendar.getInstance().getTimeInMillis(); System.out.println(\"Buffered时间差为：\" + (end - start) + \"\\n ==========================================\"); br.close(); } } ![Javadoc For Dummies_ java.io Class Hierarchy Diagram](https://gitee.com/ymyguang/picture/raw/master/img/Javadoc For Dummies_ java.io Class Hierarchy Diagram.gif) ![java_io (1)](https://gitee.com/ymyguang/picture/raw/master/img/java_io (1).png) ","date":"2021-08-04","objectID":"/posts/java/java-io/:1:0","tags":["","",""],"title":"","uri":"/posts/java/java-io/"},{"categories":["java"],"content":"Servlet相关知识 ==Servlet只是接口，是Java中的一个接口文件；== 有什么用？ 处理请求数据，进行逻辑处理和数据操作；相比之下，对于Servlet的疑惑，实际上是对Tomcat的不了解！ 就上方所说，Servlet仅仅是一个接口，其功能是提供一个网络交互的功能，里面写好了对应的接口，然而实际上起到接受请求和发送请求的是Tomcat。Tomcat将接受到的网络请求封装为对象，传递给对应的Servlet的对象；同样，Servlet所发送出去的请求也是由Tomcat发送出去的； 而Servlet并不是没有任何用处，他将各种功能封装成指定的方法方便上层调用。可以从Servlet的源代码中看出，并没有相关处理接受网络请求以及发送网络请求的任何代码； // Servlet接口中的注释说明： * Called by the servlet container to indicate to a servlet that the servlet * is being placed into service. 可以看出， servlet是被container所调用的，而这里的container就是所说的Tomcat程序； 再来servlet的方法： init ：container调用当前servlet时，首先执行该方法，开始初始化当前servlet getServletConfig() ：获取配置内容 service() ：执行逻辑代码 getServletInfo()：获取当前Servlet的信息 destory()：销毁当前Servlet 从接口的方法也可以看出，servlet仅仅是一个类，仅仅是为了规范代码以方便Tomcat调用执行相关操作！ 也可以说：Tomcat程序是按照Servlet API的接口实现的， 而Tomcat的功能就是将Java类转换成实际响应的程序，以此如果希望得到web程序（可以接受请求，发送响应），就必须满足Servlet API规范，也就是继承Servlet相关类，继承之后也即是广义上所说的Servler！ 下图是大体上的请求客户端和服务器的交互流程 ","date":"2021-08-03","objectID":"/posts/java/servlet/:1:0","tags":["java"],"title":"Servlet","uri":"/posts/java/servlet/"},{"categories":["java"],"content":"类中的一些关键方法 this.servletContext(); 用于不同的Servlet之间传递属性值，值得注意的是，多个不同的Servlet取值时，都是this.来获取的。 ","date":"2021-08-03","objectID":"/posts/java/servlet/:1:1","tags":["java"],"title":"Servlet","uri":"/posts/java/servlet/"},{"categories":["regex"],"content":"Regex Syntax 一、常用符号代表： ^ 行的开头 $ 行的结尾 \\b 单词边界 \\ 转移符号 \\\\ 反斜杠 () 表示子表达式的开始和结束 二、字符代表 \\d 数字 ———— \\D 非数字 \\w 字母 ———— \\W 非字母 \\s 空白字符 —— \\S 非空白字符 .匹配除换行符和回车符之外的任意字符，等于[^\\n\\r] 简言之就是：小写的转义代表着本身的含义，大写的代表着小写含义的反向含义 三、字母范围 这里类似集合中的运算规则，所使用的符号是：中括号[]，因此当匹配正常的中括号时，需要使用转移使用 [abc] 匹配包含其中任意之一字母的字符串，==务必要注意不是完全匹配！== [^abc] 四、出现==次数== ? 前面字符出现次数：小于等于1 == 最多出现一次 + 前面字符出现次数：大于等于1 == 最少出现一次 * 前面字符出现次数：任意值 === 任意出现次数 {n} 这里的n 就是前方字符出现的次数，分别有以下情况 {n} 指定出现的次数 {n,} 最少出现n词 {n,m} 出现次数为Nm之间的范围 五、贪婪和非贪婪模式 贪婪：顾名思义，就是尽可能的匹配更多的符合当前条件的内容 ​ 表示符号：\u003c.*\u003e ，实际上的修饰符号是：* 非贪婪模式：只要找到符合条件的内容，就暂停寻找直接结束 ​ 表示符号：\u003c.*?\u003e，实际上的修饰符号是：*？ ","date":"2021-07-30","objectID":"/posts/basic/regex-syntax/:1:0","tags":["regex","basin"],"title":"Regex Syntax","uri":"/posts/basic/regex-syntax/"},{"categories":["前端","html",""],"content":"跨域的一些知识 什么是跨域？ 跨域是浏览器端为了防止恶意AJAX的请求，只允许同7的请求，禁止跨域请求，这里的同域要求是：同协议，同域名，同端口；只要有一项不一样，就k会被认为是跨域请求，浏览器就不会发起；实际上这种激进的方式，在现在的开发中跨域是一个很常见的请求，因此需要解决这种”拦截“； 在CORS问世之前，有各种曲线的方法来避免这种问题，比如说直接用同域发起请求，但是请求附加着实际的参数，后端拿到后，在向实际的域名发起请求，并将结果返回倒当前页面的Ajax，真正意义上来讲，这种方式并没有解决以上的问题，只是绕开了此项限制；但是CORS的出现便彻底解决了此问题，其方式就是在HTTP的请求头中加上一些字段，这些字段有的是写给浏览器的，有的是写给后端服务器的，不过实际上是取决于浏览器是否发送请求决定的； CORS(Cross-origin resource sharing) 跨域资源共享 CORE有两种方式，方式的选择取决于请求头的格式，请求头的格式分为： 简单请求 复杂请求 简单请求 满足一下两项条件的都属于简单请求 请求方法属于一下情况之一： HEAD GET POST HTTP请求头信息只包含一下字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 复杂请求 显然，只要是不满足以上简单请求的，当人就是属于复杂请求 对于请求的处理方式 浏览器对于不同的请求有着不通过的处理方式，想当然，对于简单的请求有着相对简单的处理方式 直接在头部信息中添加字段：Origin 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 那什么情况下，才会被浏览器认为是合法的请求呢？（浏览器把这个请求发出去） 当浏览器自动发送请求后，收到的相应中包含以下字段时，本次请求才会生效 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar 第一个字段代表的是服务器允许的域，可以是请求的域名，也可以是*，代表接受所有的跨异请求【必选】 第二个字段：代表是否发送Cookies【可选】 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 var xhr = new XMLHttpRequest(); xhr.withCredentials = false; 第三个字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。 复杂请求的处理方式： 同简单请求方式不同，复杂的请求方式中，浏览器会先进行一场”预检“请求，只有当该请求满足条件时，才继续向 跨域站发起真正的请求；预检的请求头是：OPTIONS,下方图片就是预检的请求头； 只有当服务器所返回的消息头中包含字段Access-Control-Allow-Origin且字段的值是之前的origin域名或者是*（代表所有域名）时，浏览器才会真正的发出数据；除了以上的数据之外，还会存在以下两个表头： Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header ​ 第一个是返回所允许浏览器能够发送的请求方式 ​ 第二个是，返回服务器支持的所有信息字段 以上，当第一次通讯成功后，接下来的浏览器请求就会向简单请求格式那样，直接在请求头中加入Origin的字段信息。同样，服务器返回的消息头中，也会包含Access-Control-Allow-Origin字段； 参考地址：https://www.ruanyifeng.com/blog/2016/04/cors.html ","date":"2021-07-28","objectID":"/posts/java/%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/:1:0","tags":["前端","html",""],"title":"跨域的一些知识","uri":"/posts/java/%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"},{"categories":["","",""],"content":"Spring Boot笔记 ","date":"2021-07-28","objectID":"/posts/java/spring-boot%E7%AC%94%E8%AE%B0/:0:1","tags":["","",""],"title":"","uri":"/posts/java/spring-boot%E7%AC%94%E8%AE%B0/"},{"categories":["","",""],"content":"快速开始 核心启动类：(the entry point ),Spring 容器启动的入口点； @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } interface：ApplicationRunner,在Spring启动后，执行； public void run(ApplicationArguments arg0) throws Exception { System.out.println(\"Hello World from Application Runner\"); } 读取配置文件：application.yml Spring 会自动读取ClassPath下的该文件，取值方法如下： @Value(\"${spring.application.name}\") private String name; 当前方式只支持在注解中使用，同时为了避免当读取字段不存在时，导致Spring抛出Could not resolve placeholder ‘spring.application.name’ in value “${spring.application.name}”.异常，因此可以在朝朝属性时，在属性的背后加上默认值；@Value(\"${spring.application.name:default}\") 在实际的开发过程中，可能会面临不同的环境，因此不可避免地需要配置多个配置问价供不同的配置文件使用；此种情况有两种方式： 方式一：分离application.properties文件，不同的配置环境对应到不同的配置名称； ​ dev:application-dev.properties ​ prod:application-prod.properties 使用不同的配置文件方式：java -jar 需要运行的jar文件包 -spring.profiles.active=dev，这里需要注意的是，等号后面的值是：application-xxx.properties中的xx得的值； 方式二： ​ 使用application.yml文件配置，相比于方式一，此种方式更加简洁，配置中的结构更加清晰，另外不同的环境也不去需要分离出单独的文件，只需要—即可在文件中实现分割；但是需要指定配置文件的ID名称：对应字段：profiles:XXXX 使用方式同方式一，直接使用-spring.profiles.active=xxx指定配置名称； 输出日志 logging:file:name:log.txt The code given below shows how to add the slf4j logger in Spring Boot main class file. package com.tutorialspoint.demo; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { private static final Logger logger = LoggerFactory.getLogger(DemoApplication.class); public static void main(String[] args) { logger.info(\"this is a info message\"); logger.warn(\"this is a warn message\"); logger.error(\"this is a error message\"); SpringApplication.run(DemoApplication.class, args); } } ","date":"2021-07-28","objectID":"/posts/java/spring-boot%E7%AC%94%E8%AE%B0/:0:2","tags":["","",""],"title":"","uri":"/posts/java/spring-boot%E7%AC%94%E8%AE%B0/"},{"categories":["java","basic"],"content":"Java注解和反射 [toc] ","date":"2021-07-20","objectID":"/posts/java/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:1","tags":["java"],"title":"Java注解","uri":"/posts/java/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["java","basic"],"content":"注解Annotation Information for the compiler — Annotations can be used by the compiler to detect errors or suppress warnings. Compile-time and deployment-time processing — Software tools can process annotation information to generate code, XML files, and so forth. Runtime processing — Some annotations are available to be examined at runtime. 元注解： @target 描述使用对象 @retention 描述作用范围 @document 是否生成文档 @inherited 是否允许继承注解 声明注解时，需要使用@interface定义。另外需要注意的是，“接口”中的“方法”实际上是自定义注解的参数，下面是一个自定义的注解代码 public class Text { @MyAnnotation(name = \"ymymguang\", age = 22) public void text() { } } @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation { String name() ; int age() ; } 可以直接在参数的后面添加default字段，指定默认值； @interface MyAnnotation { String name() default \"xxx\"; int age() default 22; } 当自定义注解仅存在一个属性时，不需要在使用注解时，使用了属性名称了； public class Text { @MyAnnotation(\"ymyguang\") public void text() { } } @interface MyAnnotation { String name() default \"xxx\"; int age() default 22; } ","date":"2021-07-20","objectID":"/posts/java/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:2","tags":["java"],"title":"Java注解","uri":"/posts/java/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["java","basic"],"content":"反射Reflection **有实例化的对象得到该对象的任何信息，例如属性，方法，接口等。反射是Java被视为动态语言的关键；**动态的编译和创建。何为反射？实际上反射就是：有对象得到的带对象的类；当然不一样的对象数据只要是被的同一个类实例化，所得到的结果都是同一个； graph LR; A[\"实例化对象\"]--\u003eB[\"getClass()\"]; B --\u003e C[\"获取对象所有信息\"] 前景知识： 一个类在内存中，只存在一个Class对象 一个类被加载后，整个类的结构都被封装在Class对象当中 获取Class类的几种方法 实例化对象.getclass() Class c2 = student.getClass(); System.out.println(c2.hashCode()); Class.forname(“类名”) Class c3 = Class.forName(\"Person\"); System.out.println(c3.hashCode()); 类名.class; Class c1 = Person.class; System.out.println(c1.hashCode()); 类加载过程 graph LR; A[\"准备\"] --\u003e B[\"链接\"] B --\u003e C[\"初始化\"] 准备：将.class文件载入到内存，静态数据转换成==方法区==运行时数据结构并且生成Java.long.Class对象（为反射提供了条件） 链接：将二进制代码载入到JVM当中，在此过程中会经历：验证，准备、解析三个阶段； 验证：验证二进制代码是否符合JVM的规范，没有安全方面的问题 准备：为类变量范围在方法区分配内存，并且为其初始化变量 解析：将符号引用转换成直接引用； 初始化：执()方法。类构造器方法方法是由编译器时期所有的类变量复制动作和静态代码块中的语句组成的。 主动引用和被动引用 相关样例模板代码： class Son extends Father{ static { System.out.println(\"Son类被加载\"); } static int G = 2222; public static void show() { System.out.println(\"Son方法show()\"); } public void noStatic() { System.out.println(\"Son非静态的方法\"); } } class Father { static { System.out.println(\"Father类被加载\"); } static int M = 2; } 主动引用：主动引用的类会被初始化 主动引用的一些情况 虚拟机创建Main new 对象 reflection反射 public class Text03 { public static void main(String[] args) throws ClassNotFoundException { Class.forName(\"Son\"); } } //运行结果 Father类被加载 Son类被加载 调用类的静态成员和静态方法 public class Text03 { public static void main(String[] args) { System.out.println(Son.G); Son.show(); } } 输出结果： Son类被加载 Son方法show() 被动引用：被动引用的类不会被初始化 子类引用父类的静态变量或静态方法均不会初始化当前子类对象 /** * @another ymyguang * @date 7/21/2021 9:39 AM */ public class Text03 { public static void main(String[] args) throws ClassNotFoundException { System.out.println(Son.M); } } 运行结果： Father类被加载 2 定义数组引用 /** * @another ymyguang * @date 7/21/2021 9:39 AM */ public class Text03 { public static void main(String[] args) throws ClassNotFoundException { // System.out.println(Son.M); Son son[] = new Son[10]; } } 运行结果： （空白） 引用常量也不会初始化当前类，常量在链接阶段就被加载到方法区了 /** * @another ymyguang * @date 7/21/2021 9:39 AM */ public class Text03 { public static void main(String[] args) throws ClassNotFoundException { System.out.println(Son.GG); } } 运行结果： 2 类加载器 graph LR; A(\"系统类加载器\") --\u003e B(\"拓展类加载器\") B --\u003e C(\"引导类加载器\") 以下是各个加载器的说明，和加载顺序 使用反射获取对象信息 如下所示， import java.lang.reflect.Field; import java.lang.reflect.Method; /** * @another ymyguang * @date 7/21/2021 11:06 AM */ public class Text05 { public static void main(String[] args) throws ClassNotFoundException { Class c1 = Class.forName(\"User\"); System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); System.out.println(\"==================================\"); Field[] fields = c1.getFields(); for (Field field : fields) { System.out.println(field); } System.out.println(\"==================================\"); fields = c1.getDeclaredFields(); for (Field field : fields) { System.out.println(field); } System.out.println(\"==================================\"); // 所有的public类 ,包含继承 Method[] methods = c1.getMethods(); for (Method method : methods) { System.out.println(method); } System.out.println(\"==================================\"); //所有自己的方法，不包含继承 methods = c1.getDeclaredMethods(); for (Method method : methods) { System.out.println(method); } } } 使用反射的样例 首先要知道，反射的对象是这直接到类的，因此不管是获取方法还是获取属性。实际上都是从方法区获取的当前类的方法和属性，因此当要使用一个实例化对象的方法时，需要前提指定！ class User { private String name; private int age; public User() { } private void show() { System.out.println(\"COME FORE SHOW \"); } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 使用反射修改函数属性内容 set方法 import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; /** * @another ymyguang * @date 7/21/2021 1:45 PM */ public class Text06 { public static void main(String[]","date":"2021-07-20","objectID":"/posts/java/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:3","tags":["java"],"title":"Java注解","uri":"/posts/java/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["java","coding","it"],"content":"Maven 笔记 一、Maven是什么？ ​ Maven 是Java中自动构建代码和解决依赖的工具。主要有POM文件提供配置参数；有了Maven之后，可以快速的创建，编译、测试等功能，极大的提高了项目的调试速度；其中关键在于POM文件的内容配置，POM是一个以xml结尾的文件。内容结构类似于HTML的标签，有开始和结束的标签，属性相关内容写入到开始标签中。 以下是一个POM文件内容： \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.javatpoint\u003c/groupId\u003e \u003cartifactId\u003eCubeGenerator\u003c/artifactId\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cname\u003eCubeGenerator\u003c/name\u003e \u003curl\u003ehttp://maven.apache.org\u003c/url\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e1.7\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.7\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e3.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 简单的标签作用说明： : 组织的ID，例如以上的文件内容：com.javatpoint； 组织内的ID,此标签中的内容和上方的额中所存在的内容的拼接，能直接在在从仓库中定位到； 声明版本号，用于区分groupID和artifactID重名的工程 以上的POM问文件的完整形式实际上是继承了父类的POM文件 # 查看完整POM内容方式 mvn help:effective-pom ","date":"2021-07-14","objectID":"/posts/java/maven%E5%85%A5%E9%97%A8/:1:0","tags":["java","maven"],"title":"Maven入门","uri":"/posts/java/maven%E5%85%A5%E9%97%A8/"},{"categories":["java","coding","it"],"content":"二、Maven的简单使用 2.1. 编译项目文件 mvn clean compile # 清空之前编译的文件后，开始编译 ","date":"2021-07-14","objectID":"/posts/java/maven%E5%85%A5%E9%97%A8/:1:1","tags":["java","maven"],"title":"Maven入门","uri":"/posts/java/maven%E5%85%A5%E9%97%A8/"},{"categories":["sql","  ","  "],"content":"关系型数据库，类似于Excel中的二维表，每一行的记录和每一列的字段构,不区分大小写； ","date":"2021-07-10","objectID":"/posts/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:0:0","tags":["sql","base","  "],"title":"数据库基础","uri":"/posts/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["sql","  ","  "],"content":"基本语法 SELECT 查询表内数据 SELECT * FROM table; WHERE 筛选数据结果 WHERE col_name BETWEEN xx AND xx; 字符串匹配语句 LIKE 匹配字符串，不区分大小写 % 代表任意个数字符 - 代表一个字符 IN(“A”, “B”) NOT IN (“A”, “B”) ","date":"2021-07-10","objectID":"/posts/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:0:1","tags":["sql","base","  "],"title":"数据库基础","uri":"/posts/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["linux","note"],"content":"Linux基础入门 [toc] ","date":"2021-06-28","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:0","tags":["linux","system"],"title":"Linux基础入门","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["linux","note"],"content":"一、基础知识 RPM：将源代码和安装规则打包在一起，为了安装简便 Yum：将常用的RPM打包在一起，为了解决依赖关系（自动安装依赖），进一步结果安装难度 Linux一切皆文件！ 命令：systemctl (init) systemctl restart 服务名称 【重启服务，PID变化 systemctl reload 服务名称 【 重新加载，PID不变 systemctl start 服务名称 【启动服务 systemctl stop 服务名称 【停止服务 systemctl enable 服务名称 【加入到启动项 systemctl start 服务名称 【查看服务状态 systemd 是服务进程，systemctl 是具体的配置工具！ ","date":"2021-06-28","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:1","tags":["linux","system"],"title":"Linux基础入门","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["linux","note"],"content":"二、命令知识 SHELL是一个语言对终端进行命令发放，继而终端去控制系统；众所周知，任何东西能够实现理解的前提是：使用通用的的协议，在语言中，也就是：语法！当人和终端都遵循同一种协议时，才能实现沟通。 SHELL语法格式： ​ 命令名称 【命令参数】【命令对象】 打 【使劲】 【小刚】 亲 【狠狠】 【小红】 详细规则： 之间至少一个空格 参数 -字母 -a -l –单词 —-all –list 参数合并规则 长格式 短格式 长格式 不可以合并 不可以合并 短格式 不可以合并 可以合并（只保留一个减号，例如： -a -l -al） ","date":"2021-06-28","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:2","tags":["linux","system"],"title":"Linux基础入门","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["linux","note"],"content":"三、常见命令 系统操作相关命令 wget 下载网络文件 参数 作用 -b 后台下载模式 -P 下载到指定目录 -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源，包括图片、视频等 -r 递归下载 poweroff 关机 reboot 关机 date -s “时间” 【修改系统时间】 pwd 【当前目录】 ps 【进程信息】 1.进程信息： 1. R 当前运行程序 2. S 等待服务 3. D 不能中断 4. Z 僵死进程 5. T 停止程序 ​ 2.参数 【-x】【-u】【-a】 top 系统开机时间 终端数量 负载情况 第一行：系统时间 运行时间 终端数量 系统负载（越小越好）系统负载栏：1分钟 5分钟 15分钟 第二行：进程总数 运行中的进程总数 睡眠中的进程数 停止的进程数 僵死的进程数 第三行：已经使用【us】 空闲【id】、 第四行：内存大小 使用空间 空闲空间 第五行：虚拟内存总量 虚拟内存使用量 虚拟内存空闲 已被提前加载的内存量 Kill 【PID】 结束服务 killall 【服务名称】 结束服务（二者区别：一个是服务号，一个是服务名） history 【查询命令历史】 -c 清楚历史； !命令编号 等同于执行编号对应的命令 sosreport 搜集系统信息 查看文件相关命令 cd 目录相关 ~ 返回家目录 - 返回上一次位置 .. 返回上一次目录 ls 列举文件 注意:带点的都是系统隐藏文件 -l 详情信息 -a 所有信息 查看文件信息 cat 查看较小文件 more 查看较大文件 head -n N 查看前N行文件 tail 动态刷新文件 -f 动态追加 例子：查看日志实时更新 stat :文件属性信息 ​ access：查看时间 modify：改动时间 change：改动时间 tr 转换字符 tr [原始格式] 【目标格式】 cut 提取列字符 -d [分隔符] -f[列数] 文件名称【或文件地址】 说明：【分隔符】指的是要提取文件内的分隔符，而不是自定义，cut会按照自定义的分隔符自动划分列 diff 比较文件差异 -c 上下文模式 -u 合并模式 文件操作相关命令 touch 文件名称 【创建文件】 可以修改时间 参数：- d mkdir 【选项】目录 创建目录 -p 嵌套创建 例子：mkdir -p a\\b\\c\\d\\e\\f\\g cp 【源文件】【 目标文件】 -p 保留原始文件的属性 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r为上述参数） mv 剪切/重命名 dd 自定义复制 if input file 输入文件 of output file 输出文件 bs 数据块大小 count 复制次数 file ：查看文件类型 打包压缩\u0026\u0026搜索 tar 参数 作用 -c 创建压缩文件 -z 使用Gzip压缩或解压 【.tar.gz】 -j 使用bzip2压缩或解压 【.tar.bz2】 -v 显示过程 -C 指定解压到的目录 -x 解压压缩文件 -f 设置名称 例子：压缩：tar -czvf backup.tar.gz ./ 【将当前目录进行gzip压缩，且名字为：backup.tar.gz ​ 解压： tar -xzvf filename grep 查找文件指定 内容 参数 作用 -i 忽略大小写 -v 反向选择——列出没有关键词的行 -n 显示行号 -c 仅显示找到的行数 find 搜索 ​ /proc 目录查找文件出错 参数 作用 -name 匹配名称 -user 所属用户文件 ","date":"2021-06-28","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:3","tags":["linux","system"],"title":"Linux基础入门","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["linux","note"],"content":"四、命令结合 重定向符号 输出重定向 输入重定向 ​ 五、存储结构\u0026\u0026磁盘划分 \\bin 存放可执行文件 \\home 家目录 \\etc 系统配置文件和服务配置文件 \\boot 系统启动引导文件 \\lib 存放函数以及库文件 \\tmp 存放临时文件 ","date":"2021-06-28","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:4","tags":["linux","system"],"title":"Linux基础入门","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["linux","note"],"content":"文件权限 读[r] 写[w] 执行 execxte 命令：ll d rwx rwx rwx d -\u003e 目录 文件类型 第一组：文件的所属用户 第二组：文件的所属组 第三组：其他用户 Linux同Windows一样，都有自己的文件结构，每个文件夹内都存有一类的内容 就像Windows中的Users文件存档是的用户的数据，windows文件内存储的是系统文件，program文件夹内存放的是安装的软件的文件，等等。类似有着的Linux同样的层级关系 boot存放系统启动的相关文件 bin：存放二进制可执行文件 etc：存放系统配置文件 home：存放用户文件 root：超级用户目录 opt：额外安装包 usr：系统应用程序usr/local tmp：临时文件 ","date":"2021-06-28","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:5","tags":["linux","system"],"title":"Linux基础入门","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"千梦：“我不知道，但是我也知道你不知道。” 可以排除5月和2月， 排除五月原因：因为5月只有一种可能，如果是五月，千梦就可以知道答案，但现实是千梦不知道，因此五月排除； 排除二月原因：在所有可能的日子中，只有二月中的10日存在一次，如果燕子拿到的是10，那么燕子就会知道答案了。但现实是燕子不知道，则不是二月； 燕子回答：“你说得对，我的确不知道。” 可以排除日期为2的日子，也就是9月2日 **排除2日的原因：**当二月排除以后，燕子还是不知道，观察二月份日子，发现二月二号与九月二号有相同的日子，但是现实是燕子不知道，因此不会是2号结尾的日期 千梦接着说：“嗯，即使现在，我仍然不知道。” 可以排除9月 **排除9月的原因：**当燕子说完不知道以后，9月就只剩下一个日子，但是千梦仍然是不知道，因此可以排除9月份 燕子回答:“是的，我也仍然不知道。” 排除1日的原因 **排除1日的原因：**当九月被除掉以后，只有三月份中的1号，为单独日子，如果是1号的话，燕子就可以得出答案，但是还是没有得出，因此可以排除1日 千梦又回答道：“真糟糕，我还是不知道。” 可以排除三月 可以排除三月：通过上方排除的1号之后，3月就只剩一个3月14日，但是千梦还是能确定生日日期，就意味着不会是三月，故三月排除 燕子笑了笑说：“别急，我现在知道了。” 可以确定7月14日 **可以确定7月14日原因：**进行到这里的时候还剩下如下日期： 但是此时，燕子就可以确定日期了，则意味着该日期一定是唯一的，观察剩下的日期，只有7月14日的日子独立，因此便可以确定教授的生日就是7月14日 ","date":"2021-03-04","objectID":"/posts/think/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A2%98%E7%9B%AE/:0:0","tags":["other"],"title":"一个有趣的逻辑推理题","uri":"/posts/think/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A2%98%E7%9B%AE/"},{"categories":["coding","Java"],"content":"抽象类和接口的区别 抽象类是一个类，因此具有类的性质，即可以含有构造方法 接口是抽象方法的集合 花括号内容： 接口中的方法不允许实例化； 接口中除了static、final变量，不能有其他变量 抽象类中方法允许实例化，也可以不实例化； 可包含其他变量 继承 接口可以多个继承（实现，implements）， 抽象类，只可以单个继承（extends) 实例化 接口中，只要是是实现（implements)，就必须把接口中的所有方法实现； 抽象类中，如果子类是抽象类，可以不把父类的抽象类全部实现（但是当继承后的子类不是抽象类的时候，需要把未经实例化的方法实例化） 修饰符 接口中，只可以public 抽象类中的抽象方法：抽象类的目的就是被继承，抽象方法就是为了被重写，所以肯定不能用private修饰符，肯定是可以用public的。但是protected和default也是可以的。 修改 二者代码 接口内：增加新的方法之后，还需要在实现的类中，重新实现 抽象类中，增加方法之后，可在新增的方法内，直接实现； ","date":"2021-02-24","objectID":"/posts/coding/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["coding","Java","Tip"],"title":"抽象类和接口的区别","uri":"/posts/coding/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["basic"],"content":"2021年6月7日更新 关于commit切换的一些记录 分支、commit切换：git checkout 版本/commit标志MD5. 切换的时候，不会对本身内容进行任何的修改，同时也不会丢失任何内容！但是工作区的内容是会变的（变成了指定的checkout，但是实际上没有任何变化） 不管有多少分支，实际上都是跟着commit的提交而改变的，只不过是commit的提交在当前分支下有效而已。即内容版本是已经隐式的先前更新了； git merge的合并若产生冲突»»»到=========之间是第一个，从========到««««««««««是第二个，也就是说=========是冲突的分界线 手动修复好冲突之前，终端保持在一个挂起的状态 修改之后，还需要重新提交代码（因为合并类似一个修改代码的操作） git 用好了真的事半功倍！ ","date":"2021-02-24","objectID":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["git","basic"],"title":"Git 笔记","uri":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["basic"],"content":"2021年2月24日更新 撤销操作 git checkout.#丢弃所有修改或删除，不影响新增或未跟踪的文件。会递归下级目录 git clean-nxdf#dry-run，先看下即将删除那些文件，再执行下面的危险命令 git clean-df#删除所有未跟踪的文件和目录(不包含.gitignore的文件），危险命令 git clean-xdf#删除所有未跟踪的文件和目录（同时包含.gitignore的文件），危险命令 代理操作： git config --global proxy.http=\"http://127.0.0.1:1080\" git config --global proxy.https=\"socks://127.0.0.1:1080\" 撤销： git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2021-02-24","objectID":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["git","basic"],"title":"Git 笔记","uri":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["basic"],"content":"Git笔记 1. Git是什么 Git是世界上最先进的分布式版本控制系统 Workspace：工作区 Index/Stage：暂存区 Repository：仓库区（本地仓库） Remote：远程仓库 2. 基本操作 文件操作： 创建文件：touch 文件名.* 删除文件：rm 文件名 创建文件夹：mkdir 文件夹名 删除文件夹：rm -r 文件夹名 查看文件：cat 文件名 恢复历史版本 git reset --hard HEAD^ 退回上一个版本 git reset --hard HEAD^^ 退回上上一个版本 git reset --hard HEAD^^^ 退回上上上一个版本 git reset --hard HEAD~100 退回第100个版本 git reset --hard 版本号 退回版本号版本 (查看版本号:git reflog) 修改相关： 放弃历史暂存区文件修改：git restor git chackout -- 文件名 初始化仓库：git init 添加文件到暂存区 ：git add filename 提交文件到仓库：git commit filename 查看暂存区当前状态：git status 查看暂存区文件修改情况：git diff 查看最新文件修改记录：git log 简洁呈现：git log -pretty=online 查看所有文件更改记录：git reflog 清空暂存区：git rm --cached filename; re ./git/index 暂存区文件 分支： 创建分支：git branch [分支名称] 查看分支：git branch -v 切换分支：git checkout [分支名称] 合并分支：git merge [要求被合并的分支名称] 远程： 推送：git push origin master 拉取：git pull origin master pull和clone的区别，pull是拉去远程的某个分支，clone是直接把远程的所有信息都下载下来，比如日志信息，其他分支等 时光穿梭机（版本恢复） 命令说明： git rm 删除工作区文件，并且把删除记录提交到暂存区（git rm[name]相当于：rm + git add[name] ） rm 删除工作区的文件。 恢复的方法： git checkout filename 对于checkout的说明： 情况一：当暂存区存在该文件时，将暂存区文件恢复到工作区 情况二：当暂存区未存在该文件时，将版本库中的文件恢复到工作区 git reset HEAD^ filename 作用：把上一个版本filename拉取到暂存区，此时工作区并不存在该文件，但是当我们执行git checkout filename 文件在工作区就会被找到！ 尝试情况： 情况一：提交到暂存区，不提交文件库 rm删除，工作区文件不存在，暂存区没有同步最新情况 恢复 git checkout filename 工作区恢复成功，来源暂存区，可以看出add是把文件放到暂存区中 git reset HEAD filename 恢复失败（考虑原因是因为没有可恢复的仓库） git rm删除，工作区文件不存在，暂存区更新删除记录，即暂存区该文件执行删除操作 git checkout filename 恢复失败（原因：因为给git rm=rm + add,此时暂存区该文件的记录，因此checkout会尝试在暂存区中恢复文件到工作区，但是暂存区中只有该文件的删除行为，而文件却不存在，因此恢复失败） git reset HEAD^ – filename恢复成功 情况二：提交到暂存区，提交到文件库 rm删除，工作区文件不存在，暂存区存在 git checkout filename 工作区恢复成功 git reset HEAD^ – filename恢复成功 git rm删除 git checkout — filename 恢复失败 git reset HEAD^ filename 此时操作区并未恢复文件 当在执行：git checkout filename 此时，工作区恢复了该文件 3. 错误异常 1. 执行：git push origin master 报错：error: src refspec master does not match any，远程仓库与本地仓库的之前版本不匹配，无法进行不丢失的推送（合并） 解决方法：git pull origin master git add git commoit -m \"x\" 将远端的仓库拉下来，并于本地合并，之后再进行网络推送就可以了 解决链接：https://blog.csdn.net/dietime1943/article/details/85682688?depth_1-utm_source=distribute.pc_relevant.none-task\u0026utm_source=distribute.pc_relevant.none-task 2. 执行：git push origin master 报错： Updating an unborn branch with changes added to the index.（使用添加到索引中的更改更新未生成的分支。） 其实也就是本地的仓库没有提交，无法推送远程仓库 解决方法：git commit -m \"m\"//作用：把暂存区的操作同步到本地的仓库中 情况一： 未commit（有add/无add，均无效） error: failed to push some refs to ‘https://github.com/ymyguang/text.git' 提交后，commit，推送完成 情况二： 本地编辑文件后，GitHub同时编辑文件后，推送本地仓库，失败，此时情况已提交 操作：pull拉取后，要求输入拉取说明。拉取成功。本地文件填充，（非同行） 操作后，再次推送，成功。（怀疑是检测版本号） 尝试使用–rebase ，拉回2.txt，再次提交后，正常，推送正常 尝试本地删除，2.txt,不新建，直接推送，成功 ，新建其他文件，推送，成功！ 尝试修改不同文件：在两端同时修改，此次报错，由此可见：只要远端的版本不是与本地的版本书不匹配，将无法push 分析：如图 ","date":"2021-02-24","objectID":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["git","basic"],"title":"Git 笔记","uri":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["basic"],"content":"Git文件恢复问题 设想一下，你有一个文件夹，打算自己的去DIY，但是由于自己的失误，把整个文件夹都搞得乱哄哄的这时候就需要Git来解决。 在Git中分为三个区域，分别是工作区，暂存区，仓库区 作用 当我们修改文件，就在工作区 修改文件后，把需要提交的文件，放到暂存区 确定需要的文件都在暂存区之后，将暂存区的文件传到仓库区 撤回文件： 丢弃工作区的修改 文件的修改：checkout 撤销对原存在文件的修改，注意，是撤销对原文件（最近一次add或者是commit）的修改，对于新的文件的增加，和新的文件的删除，将无法恢复。 （丢弃工作区对先前存在文件的修改，使之恢复到最近的一次add或者commit。） 文件夹的创建：git clean .使整个文件区的任何操作进行撤销。 丢弃（退回）暂存区修改：git reset HEAD ,此时暂存区域的文件就被退回到工作区，如果我们需要继续清除工作区 ，直接重复第一步的操作就可以了 ","date":"2021-02-24","objectID":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["git","basic"],"title":"Git 笔记","uri":"/posts/md/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"计算机网络 ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:0:0","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"绪论 应用层 常见协议：HTTP,FTP,POP3,SMTP 传输层–进程到进程之间 TCP，可靠传输；UDP 非可靠传输 网络层–端到端之间（主机之间）E2E 传统方式： 数据平面：IP 控制平面：路由 工作方式:路由之间相互传递信息，其中包括子网，延迟，跳点等。由路由算法绘制出路由表;IP通过路由表选择需要走的端口信息； 现代方式:SND 数据平面：IP 控制平面:网络系统 数据链路层–点到点之间P2P 传输方式：单位为：帧 物理层 作用：将网络信号转换成物理信号 ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:0","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"什么是Internet？ Internet是一个由多个网络构成的网络实体。其中包含了成千上万的子网络。 从组成上来看： 节点（端系统） 主机（host）节点:手机，笔记本，Pad 交换节点；路由器，交换机，负载均衡设备 边（链路） 接入链路：将端系统接入到因特网的链路（边） 骨干链路：连接交换设备的链路 协议 定义：规定了在两个设备及以上设备之间的交换报文的：语法，语义，次序，动作； 目的：为了在不同设备商之间制造的设备仍热能够准确的传递报文，确保报文的语义一致性； 从服务上看： ​ 互联网为，端系统上所运行的分布式程序之间的通讯提供服务的基础设施； ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:1","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"一、网络边缘 计算机网络由网络边缘和网络核心组成；其中网络边缘是指：终端设备和接入链路（接入网）； 接入网 将接入网拆开来看，分成接入技术和接入媒介;在接入技术中，方式多种多样，但是基本上都是按照一下的模型进行布局： 用户端-\u003e“翻译器“（模拟信号\u003c=\u003e数字信号)—\u003e中心局(CO)复用器（模拟信号\u003c=\u003e数字信号)-\u003e因特网 *1.*家庭用户 将网络介入家庭用户中，常见的有两种方式： DSL接入–数字用户线 电缆接入 光纤接入 以上两者均是利用已经存在的物理媒介进行传输数据。光纤是直接引用新的物理媒介； 1.1DSL接入 DSL(Digintal Subscriber Line)指的是利用已经存在的本地电话公司的线路，利用调制解调器将数字信号转换成模拟信号以便线路传输， 用户端：用户使用同一根电话线路用于传输电话信号和网络信号。区分两种信号的方式将两种的信号频率固定到一定范围，最后再有分频器将两者信号分开。网络信号有调制解调器负责翻译，电话信号传输给电话使用；在生活中，常见说的“猫”就是调制解调器。 服务端：服务端提供DSLAM（Digintal Subscriber Line Assess Machine)数字用户线接入复用器类供用户端的DSL使用双绞铜线与之链接。其中DSLAM的作用与分频器类似，将网络信号和数字信号隔离开，并将网络信号推送到互联网当中； 特点：只有在用户与中心局间隔较近的情况下才会使用DSL的接入方式。因为DSL所使用的是双脚铜线，不利于远程的数据传播。距离大约在：8-16公里 1.2电缆接入 全名电缆因特网接入。相比DSL的利用本地电话局的电话线进行网络传输，电缆接入的方式则是利用了本地有线电视的线路。但是与上着不同的是，DSL的传输线路完全有双绞铜线进行传输，而在这种传输方式所用的物理材料媒介是：混合光纤同轴（HFC)，即使用光纤和电缆。 其特征于接入方式类似DSL，且上行速度于下行速度不对称。 1.3光纤接入 完全使用光纤进行信号传播。术语叫做:光纤到户（FIber To The Home).这个技术中最简单的是直接从中心局引入一根光纤接到用户端，但是这种接入方式耗资巨大，因此通常采用由中心局CO引出来的一根光纤，在靠近用户群体的附近再将该光纤分成多个口 ，再有单独的光纤接入每一个用户。有多个用户共享使用，目的很简单就是为了节省经费。实际上这种方式这种方式于上面的两个接入方式也有着异曲同工之妙。 在光纤到户这种接入技术中有两种光线分布体系结构： 主动光纤网络（AON） 被动光纤网络（PON) 准确来讲被动光纤网络才类似于上述的接入方式。在总光纤于单个光纤之间有一个叫做：光纤分配器设备。每个用户的家中需要安装一个叫做ONT（Optical Network Terminator)光纤网络端接器的设备。作用和调制解调器类似，都是将模拟信号于数字信号之间进行转换； 2.企业、学校接入 由于企业和学校等大型组织有大量的人员和范围。使用上述的三种方式接入显得力不从心，因此无线接入运营而生。其中最为普遍和流行的接入技术是基于：IEEE802.11技术。也就是我们常说的WiFi。 二、物理媒介 尽管有很多的接入方式，但是基本结构都基本相同，不同的接入方式之间的所造成的差异很大程度设上都取决于传输媒介。 导引型媒体–能看见的 非导引型媒体—看不见的 常见的物理传输媒介： 双绞铜线：是由两根具有绝缘保护层的铜导线组成的。把两根绝缘的铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。 同轴电缆：有两个同心导体，而导体和屏蔽层又共用同一轴心的电缆。最常见的同轴电缆由绝缘材料隔离的铜线导体组成； ​ 光纤：一种细而柔软、能够引导光脉冲的物理媒介 无线电：一种通过电磁波进行传输的物理介质 ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:2","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"二、网络核心 在网络通讯中，网络核心起着至关重要的作用。主要作用是完成在网络上的路由和转发功能； 网络通信有两种方式： 分组交换 电路交换 分组交换 将源系统发送的数据分成小的数据块，其过程称之为分组。每个小的数据包通过不同的路由器的路由和转发到达指定的目标主机；但是在传输过程中，路由器和交换机不维持连接状态。在分组交换中，有以下规则： 存储转发机制 该机制保证了每个路由器在完全接收到数据包之后，再开始进行转发操作；换言之，当交换机或者路由器没有收到完整的分组数据包，将处于挂起状态，直至整个数据包完整到达。即先存储再转发；所以计算传输时间的时候不应该忽略存储的时间；例如当一个大小为L 的数据包在传输速率为R的链路上 传输，其中需要经过一个路由器，到达目标主机，此时需要传输到长时间才能到达目标主机？ 分析： 首先：端主机的L bit数据包到达R时间，在链路中需要$L/R$秒时间。这个时间实际上也是在路由器中存储数据的时间（因为一段的发送就代表着另一端的接受），同样当路由器的数据完成缓存之后，将开始进行转发操作，在经过$L/R$秒时间，数据包完整到达目标主机； 补充：当P个数据分组经过N个速率为R的传输链路，所需要的时间是：$\\frac{NL}{R} + \\frac{(P-1)L}{R}$ 秒； 解释一下：这里以4个分组，2个路由器（3条链路）举例，也就是说这里的P为4，N为3 如上图，每一个条形格的长度代表着传输时间都是$\\frac{L}{R}$，以第一个为参考，则之后的每一个分组传输时间都需要$\\frac{L}{R}$秒，所以不难得出公式：$\\frac{NL}{R} + \\frac{(P-1)L}{R}$。第一项是第一个数据包传输的绝对时间，第二项代表第一个分组之后的数据包传输的相对时间； 排队延时和分组丢失 以上的两种特征均有【存储转发机制】的特点所导致的；一个中转器的缓存空间一定是有边界的，同时一个路由器很有可能同时服务于多个用户，但是交换机设备的转发又是有并发限制的，所以当交换机接受的数据大于所做转发的数据，就会将多出来的数据放到队列当中进行排队转发，这个排队的时间就是排队延时。因为网络情况是不确定，所以排队延时也是一个不确定的因素； 同时很自然的可以想到，当一个路由器的缓存空间被盛满之后，之后再来的数据包将会被舍弃。原因也很简单，就是因为路由器已经没有存放数据的空间了。而这个过程就是上述所说的分组丢失； 路由表和路由选择协议 路由表和路由选择协议的唯一目的就是：给数据指路，知道数据应该往哪一个链路上进行转发，从而实现数据的传输。每一个数据包中都含有一个目标地址的IP，每一个在公网上的IP都是唯一的（但是现在的IP4已经被用完了，现在正在推广IPv6).因此在路由表中，会查询不同IP对应的不同的转发链路，从而实现了数据的正确转发； 电路交换 电路交换，有一个很大的特点：线路独享！电话网通常采用这种交换方式，因为这中传输方式能够完全保证数据链路的稳定的。在连接之前，会有一个称之为”信令“的信号在整个线路传输，旨建立起一个预留的链路通道。 实现原理：将每一个通讯链路划分成多个对等或不等的逻辑上的小片。这些小片可以并行通讯交换数据；当两个端系统进行通讯之前，端系统发送信令，在链路中寻找出空闲的小片，直到创建出一个端到端的连接线路。 举个例子：假如说一个链路分成四片，其整条链路的传输速率为：1Mbps,那么每一条线路的传输速率理论上将能达到250Kbps. 上面提到的：逻辑上分成小片。常见的划分方式有：FDM(波分复用），TDM（时分复用），不论是波分还是时分都是将物理链路划分逻辑小片。所谓的时分或波分无非是不同的技术；波分是将不同频段的频率分配为并行的小片。我们所说的带宽就是使用的波分的方式。带宽的大小其实就是该片中频率之差，也就是范围；时分是将单位时间分隔成不同而时间间隙（时隙），对应的时隙分配给不同的用户，单位时间内，一个用户的数据最多只能被传输一次，如果某用户传输数据时擦超过了对应的时隙，那么只能等到下一个单位时间后才可以传输数据； 除了时分和波分之外，在光纤中还有一个叫做频分复用的复用方式； 电路交换于分组交换的区别与联系 **联系：**目的均是为了通讯，两者只不过是不同的交换方式； 区别： 电路交换和分组交换最大的区别在于：线路的共享性；分组交换极大的提升了电路交换的共享性，使得所支持的用户数量有很大的提升； 稳定性：由于分组交换的共享性的特点，牺牲了时间和稳定； 时间：对排队延时的计算无法把握 稳定：因为分组交换中有丢包的机制，因此将通讯变得不够稳定； 目前整个网络绝大多数的交换方式都在采用【分组交换】因为分组交换简单高效且成本较低；尽管有着时间的不确定性和丢包等特征，但是由于传输速率很快，这些时间在有些情况下可以忽略不计，因此电路交换也在慢慢的向分组交换进行转变 ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:3","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"三、交换时延及网络性能指标 交换时延 时延：在[计算机网络]中进行[分组交换]，[分组]从一台主机（源），通过一系列[路由器]传输，在另一台主机（目的地）结束它的进程。当[分组]从一个节点（主机或路由器）沿着这条路径到后继结点（主机或[路由器](）时，该分组在沿途的每个节点都经受了几种不同类型的时延（Delay）。 之前说到，在分组交换中需要，当进入路由器的数据包大于出去路由器的数据包的情况下，多出来的数据包会进行排队等待，因此很显然在交换时延中，排队时延便是一个不可忽略的因素；同时进路由器的数据包需要在路由器中被处理。例如进行一系列的封装和解封装，在这个过程中所消耗的时间被称作：节点处理时延。接着数据在被路由器处理完成后，需要向外界链路发送，这里的发送也不是一瞬间的，例如有L大小的分组，从路由器A到路由器 B进行发送数据，两个路由器之间的链路带宽时Rbps，那么就要路由器将所有数据推到链路中的时间为$\\frac{L}{R}$秒。这个时间跟上文中提到的：先缓存后转发的缓存时间是一样的！两着只不过是从两个角度对时间进行运算。从发送数据的路由器来看，这个$\\frac{L}{R}$的时间被称之为传输时延；从接受数据的路由器一段来看这个时间可以叫做缓存时间；两着从不同的端看进去采取的数据端也不一样；当以发送端为参考端，需要观察数据的尾端；反之亦然 ，接收端为参考端，则需要数据的尾端，这里一定要注意区分；除了以上的三种时延之外，还有一个取决于物理空间的时延：传播时间，即：在物理空间中的链路传输中所需要的时间，理想情况下这个时间时确定的也就是 $\\frac{S}{v} $ 这里的S是两者之间的空间距离，V也就是物理介质的传输速度，例如光的传播速度：$3\\times10^8$m/s。但是由于在实际的传输中 会受到不可控的干扰，因此一般情况下传输时间都会小于物理介质的理想传输速度； 整体的网络传输时延就是以上四个时延的累计之和： 节点处理时延 排队时延（不可控） 传输时延 传播时延 $$ 总时延： d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop} $$ 网络性能指标 流量强度：由于排队时延具有不确定性，但是人们总是尝试将不确定性的事物想尽一切办法使之变得可以衡量和可控，最起码可以知道发展趋势，既然不能定量的衡量计算排队时延的大小，便使用定性的方式来预测排队延时的发展状况；因次流量强度 就是一个衡量的指标；$\\frac{aL}{R}$就代表着流量强度；a所表示的是分组到达的平均速率，那么到达队列的平均分组速率便是aL,R是链路的传输速率，实际上两者之比的值代表着两者的关系大小；需要强调的是当流量强度的值为：1的时候，排队时延的值将趋向于无穷大，因此在设计系统时，最基本的一点就是要保证：流量强度不能达到一； 吞吐量：通俗的说就是段与段之间的整体传输速率，我们平时电脑上说显示的下载速度实际上就是瞬时吞吐量，与之对对应的还有平均吞吐量，这是一个很重要的网络指标；在两端主机通讯时，其吞吐量取决了该链路中最小的带宽大小，这一点也不难理解；但是当一条链路中有多条用户使用时，吞吐量还会变得更小，其中最小的传输速率称之为：瓶颈链路 = $min{{(R_{1},R_{2},….R_{n})}}$; ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:4","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"四、协议层次和服务模型 ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:5","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"互联网层次结构 因为这个网络结构是一个极其复杂的系统，直接进行分析设计难度极高，复杂性极大。所以采取一个有效的设计模型使整个系统的基础，分层就是一个设计复杂系统很好的一个方式。将整个网络分割成不同的模型，各模型各司其职，尽最大努力完善自己所在的模型，层与层之间只需要提供接口为上层提供服务。一因此在计算机网络中，整个网络被分为5层次 ，分别是： 每一层都已自己独有的协议组成，所有层次中所有的协议被称之为协议栈，就像上文所说，每一层都有每一层的责任和特有的功能； 应用层：网络应用程序及他们的应用程序协议存留的地方,分组称之为报文 传输层：程序与程序之间传送分组，分组称之为报文端 网络层：端主机之间传送的分组，分组称之为数据报 链路层：相邻节点之间传输分组，分组称之为桢 物理层：传输物理信号 OSI模型 OSI（Open Systems Interconnection) 开放系统互联模型有7层； 很显然，此模型比因特网多了“表示层”和“会话层”，实际上在因特网中之所以没有设计这两层的原因，是为了将这个选择交给开发者，当开发者需要以上的表示层和会话层的功能时，只需要自己设计。如此保证了整体的因特网层次不过与臃肿。 ","date":"2021-02-24","objectID":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:6","tags":["computer","network","basic"],"title":"计算机网络","uri":"/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["记录"],"content":"搭建Hugo Blog 之前在网上寻找资料时，无意看到一个很简约的博客，功能也都很完整。很幸运地是在GitHub联系到了站长，通过站长的回答和不断比对站长文件目录。现在终于有了一些博客的样子了。 ","date":"2021-02-23","objectID":"/posts/recore/establish_blog_record/:0:1","tags":["notes","blog","record"],"title":"搭建Hugo","uri":"/posts/recore/establish_blog_record/"},{"categories":["记录"],"content":"心路历程 搭建过程中，印象最深的就是看Hugo的官方文档了，由于是英文的，并且内容很多，一直看的云里雾里。中途好几次想要放弃，但是每每想到用来记录东西很方便，还是开始折腾了，万事开头难。不管是对比文件结构，还是查看官方文档，都不能实现想要的功能。 经过了很长的时间的搜索和比对，最终才知道实现的功能大多数都基于主题。现在说来就是对配置文件参数的调整。除此之外，英文能力极具欠缺。 ","date":"2021-02-23","objectID":"/posts/recore/establish_blog_record/:0:2","tags":["notes","blog","record"],"title":"搭建Hugo","uri":"/posts/recore/establish_blog_record/"},{"categories":null,"content":"你好，朋友。 喜欢coding，热爱分享。试图用文字和图片来留住时间！ 初中时期开始接触计算机 高二参见了信息学奥林匹克竞赛 第一门启蒙语言是C语言。。。。。 技术菜鸟。。。。。。 大“梦想”家 ","date":"2021-02-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["coding","Java"],"content":"IDEA_Java项目的运行Demo 起初是锋锦哥，让我负责流量大师的IP源地址查询任务，自己打算对开源项目进行魔改，于是乎找到了Ip2region的开源项目，打算用Java，但是比较恶心的是，项目就是运行不起来。也可以说在自己没有任何Java构建基础的情况下，尝试去运行一个相比之下，比较复杂的Java项目。 尝试运行的过程中，走了很多弯路。好在最后还是跑起来了，很大的感悟，从刚开始的懵逼，到慢慢的有了一些感性的认识，过程中处处碰壁，好几次都想要放弃，还好我没有。！！！给自己点个赞吧！或许这就是在困难中，才能前进的原因吧，想了想耗时得有4天了，一个简单的项目运行。看样子以后干就完了 。现在想想那些厉害的人，不仅是从技术值得钦佩，在学习的过程中，正是这个遇到问题不逃避，尝试解决的精神，才有大佬这一说！他们懂得多，都是在折腾的过程中，所接触的！ 不废话了。下面记录一下心路历程，避免大家少走一些弯路。我尽量 写的详细一点，之所以这次很难跑起来，就是因为百度上的教程太过于简单。 找到对应的源码文件 编译步骤：源文件—–字节码（class）——机器码 C语言中 ：源文件 —–预处理——编译——-链接 首先，文件夹内，有三个文件夹， 其他的db文件在data中， 源码文件在binding中，我这里用的是 Java源码。 maker是有关Ip2region.db生成的源码文件，暂时不要管他。我们的目的就是把这个项目跑起来，并且可以用到其中的一些功能！ 使用Jetbrain IDEA打开该项目文件，可以看到这是打开的界面 这里说一下：三角号。运行 ​ 这里的运行是需要自己自定义的，在刚开始的时候，没配置的情况下，哪怕是把它点烂，也是没有反应的。 两种运行种类：无论是哪一个，都需要配置一下运行参数。 运行整个项目，需要构建 运行单个main文件 如下图，在项目还没有进行运行配置的时候，右上角的三角好是黑色的，不能点。因此我们需要进行配置。在这里多少一句，不管软件有多复杂（也就是有多高级）有各种各样的功能，但是自己不要迷了。需要什么用什么就行。剩下的以后会接触到了！ ","date":"2020-06-29","objectID":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/:1:0","tags":["coding","Java","IDEA"],"title":"IDEA_Java项目的运行Demo","uri":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/"},{"categories":["coding","Java"],"content":"配置项目 我们随便打开一个Java文件，选择编辑运行信息。 选择应用程序 ","date":"2020-06-29","objectID":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/:1:1","tags":["coding","Java","IDEA"],"title":"IDEA_Java项目的运行Demo","uri":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/"},{"categories":["coding","Java"],"content":"完善配置信息 这里要选择的是，当前文件的类 注意这里是，要选择构建，要不然文件夹内的Java不能被转换成class文件；Javau运行的第二部都没有实现，Java肯定运行不起来； 配置好之后，小三角就可以点击了。我们点击三角号之后，会弹出报错 很明显，是因为idea所使用的jdk的版本太低，因此我们的任务就很明显，去修改jdk的版本。在设置中的找到如下选项：并将目标字节码版本改成8； 再次点击运行后，程序就已经跑起来了； 此时我们的项目就已经可以运行了，值得注意的是，刚才我们选择了构建，所以该项目文件夹下的所有Java都被转换成class文件，因此单个项目文件中的Java运行的时候，就可以找到这个文件内的其他类。（Java在识别类的时候，只认识class，不认识Java） 接下来，我们编写一个测试类 package org.lionsoul.ip2region.test; import java.io.File; import java.lang.reflect.Method; import java.util.Scanner; import org.lionsoul.ip2region.DataBlock; import org.lionsoul.ip2region.DbConfig; import org.lionsoul.ip2region.DbSearcher; import org.lionsoul.ip2region.Util; public class IPUtil { public static String getCityInfo(String ip) { //db String dbPath = \"C:\\\\Users\\\\admin.000\\\\Desktop\\\\java1\\\\src\\\\main\\\\java\\\\org\\\\lionsoul\\\\ip2region\\\\test\\\\ip2region.db\"; //这里填写IP2region的绝对路径即可 File file = new File(dbPath); if (file.exists() == false) { System.out.println(\"Error: Invalid ip2region.db file\"); } //查询算法 int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree //DbSearcher.BINARY_ALGORITHM //Binary //DbSearcher.MEMORY_ALGORITYM //Memory try { DbConfig config = new DbConfig(); DbSearcher searcher = new DbSearcher(config, dbPath); //define the method Method method = null; switch (algorithm) { case DbSearcher.BTREE_ALGORITHM: method = searcher.getClass().getMethod(\"btreeSearch\", String.class); break; case DbSearcher.BINARY_ALGORITHM: method = searcher.getClass().getMethod(\"binarySearch\", String.class); break; case DbSearcher.MEMORY_ALGORITYM: method = searcher.getClass().getMethod(\"memorySearch\", String.class); break; } DataBlock dataBlock = null; if (Util.isIpAddress(ip) == false) { System.out.println(\"Error: Invalid ip address\"); } dataBlock = (DataBlock) method.invoke(searcher, ip); return dataBlock.getRegion(); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String[] args) throws Exception { String ip; Scanner in = new Scanner(System.in); ip = in.nextLine(); System.err.println(getCityInfo(ip)); } } 继而去，重新构建一次，产生class文件，之后直接运行该文件中的main方法，即可 到这里整个项目就可以跑了； ","date":"2020-06-29","objectID":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/:1:2","tags":["coding","Java","IDEA"],"title":"IDEA_Java项目的运行Demo","uri":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/"},{"categories":["coding","Java"],"content":"后记 也许看着很简单，但是自己搞了很多天，不是因为出什么问题，而是不知道往哪里去想，这才是最耗时，最耗精力的东西。 其实更详细的东西肯定还有，起初我搜索了Junit，maven，搜索各种报错信息，更改JDK版本，等等等等，还好自己i坚持了下来，成功的那一刻，之前的苦逼碰壁完全值得了！ 也许网上没有手把手的教程，可能是太简单了吧。嘤嘤嘤‘ ","date":"2020-06-29","objectID":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/:1:3","tags":["coding","Java","IDEA"],"title":"IDEA_Java项目的运行Demo","uri":"/posts/ed/ip2region%E8%AE%B0%E5%BD%95/"},{"categories":["linux","basic"],"content":"linux无法解析`$’\\r’`报错 今天在Windows上编写好shell脚本，在本地测试时成功的，但是当我把脚本放到服务器上，centos的系统上运行时，报错。 我对比了自己的shell文件，并没有发现**’$’\\r’‘**这个符号，自己很是困惑，把这个关键词放在加上Linux在Google搜索后，才发现时Windows换行符于Linux的换行符不相同的原因导致的！ 在Windows中，换行符是：\\r\\n 而Linux系统中，换行符是：\\n 所以在Linux内肯定没办法执行。我在notepad++中，将CRLF模式切换成LF模式后，顺利解决； 其他解决方案安装插件 apt install dos2unix # 此插件作用就是解决换行不兼容问题 在这里说一下：CRLF以及LF 两者都是换行的意思，一个是在windows下，一个是在Linux下。 其中 CR(Carriage Return) 代表回车，对应字符 '\\r'； LF(Line Feed) 代表换行，对应字符 '\\n'； 有关回车和换行的背景 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 Unix系统里，每行结尾只有“\u003c换行\u003e”，即\"\\n\"；Windows系统里面，每行结尾是“\u003c换行\u003e\u003c回车 \u003e”，即“\\n\\r”；Mac系统里，每行结尾是“\u003c回车\u003e”，即\"\\r\"；。一个直接后果是，Unix/Mac系统下的文件在 Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 ","date":"2020-06-29","objectID":"/posts/ed/linux%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90r%E6%8A%A5%E9%94%99/:1:0","tags":["linux","problem","character"],"title":"linux\\$\\r报错问题","uri":"/posts/ed/linux%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90r%E6%8A%A5%E9%94%99/"},{"categories":["coding","basic","sql"],"content":"MySQL Note ","date":"2020-06-29","objectID":"/posts/md/mysql_note/:0:0","tags":["coding","basic","sql"],"title":"Mysql 增删查改","uri":"/posts/md/mysql_note/"},{"categories":["coding","basic","sql"],"content":"概念 ","date":"2020-06-29","objectID":"/posts/md/mysql_note/:1:0","tags":["coding","basic","sql"],"title":"Mysql 增删查改","uri":"/posts/md/mysql_note/"},{"categories":["coding","basic","sql"],"content":"用法 SELECT 选择列（column) 即，输出列； 用法 SELETE 列名 FROM 表单； 执行顺序 FROM -\u003e SELECT 例子： SELECTcustomerNumberFROMcustomers; 结果： ORDER排序语句【ORDEN BY】 用法：伴随着SELECT使用，对筛选出来的结果进行排序 升序：ASC —ascending 降序：DESC —descending 例子： SELECTcontactLastname,contactFirstnameFROMcustomersORDERBYcontactLastnameDESC,contactFirstNameASC; 结果： 需要注意的是，多个排序的时候，是对前面已经排序之后的结果进行下一个列中的排序，即在第一个排序的基础上，进行排序（第一个不会再发生变化） WHER筛选语句 基本用法：搭配SELECT…..FROM…..使用 SELECT ….. FROM…… WHERE…. 例子： SELECT officeCode FROM employees WHERE officeCode \u003e 1 结果： ![image-20201029204156561](https://gitee.com/ymyguang/picture/raw/master/img/image-20201029112432550.png) - 可配参数： - ```sql [AND] [OR] [IN] [LIKE] [BETWEEN * AND *] [IS NULL] ``` - 操作符号： ![image-20201029204627660](https://gitee.com/ymyguang/picture/raw/master/img/image-20201029204627660.png) ","date":"2020-06-29","objectID":"/posts/md/mysql_note/:1:1","tags":["coding","basic","sql"],"title":"Mysql 增删查改","uri":"/posts/md/mysql_note/"},{"categories":["coding","Python"],"content":"Python传参坑 起初在学习Python中的yield中，以杨辉三角练手。 在网上找到了这样的一串代码 L=[1] yield L while True: L=[([0]+L)[m]+(L+[0])[m] for m in range(len(L)+1)] yield L 这段代码很奇妙，通过前后移位继而相加的方式，达到了杨辉三件的每一层。我想把他改写成for循环的方式，但是随着报错的不断深入，感觉对我而言并没有这么简单。 ","date":"2020-06-29","objectID":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/:0:0","tags":["coding","Python"],"title":"python参数传递","uri":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/"},{"categories":["coding","Python"],"content":"开始踩坑 这是最接近正确的代码 def yh(): L = [1] yield L while True: L1 = [0] + L L2 = L + [0] L.append(0) for m in range(len(L)): L[m] = (L1[m] + L2[m]) yield L results = [] n = 0 for t in yh(): results.append(t) n = n + 1 if n == 10: break for t in results: print(t) 但是出现的问题是：存放结果的results中，一直是多个重复的list，经过调试发现，results中的值跟随着L的变化而变化。每当L被操作的时候，results中的结果也会发生变化。 为了解决这个问题，尝试了很多方法，开始时以为是yield的用法不理解，就一味去了解yield用法，但尽管知道了用法之后还是不能结果以上的问题。仔细想了一下，怀疑是results指向的对象和L所指向的对象是一个地址，所以导致了两者同时变化。事实证明猜想是正确的。 迭代器–yield 为了解决列表占用大量内存空间的问题，迭代器就是一种时间换空间的解决方案，迭代器在执行过程中会对类似函数中的代码进行计算，如此一来就节省了空间；下面是yield的特点 特征一：含有return的功能，可以将值返回到调用位置 特征二：会记录“函数”上一次执行的位置，下次迭代时，会从上一个位置继续进行。因此迭代“函数的”内容是会被保存的，而且会记录上一次的执行位置。 于是我开始尝试使用return去解决问题，但是还是无济于事（当时还是没有意识到不是yield的问题）。 ","date":"2020-06-29","objectID":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/:0:1","tags":["coding","Python"],"title":"python参数传递","uri":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/"},{"categories":["coding","Python"],"content":"填坑 又经过一阵子搜索，发现Python中传参和C中的传参大为不同。在C中，默认的传参方式是传值调用。而在Python中，得益于一切皆为对象的原则，所以并没有默认的传参类型。 具体传参方式为： list等可变数据类型为所传参数时，是传地址。即C++中的引用。新变量名称仅仅指向赋值对象的地址（新变量随原参变化） tuple等不可变的数据类型为传值。即复该值后，开始重新赋值。（新变量不随原参变化） 如此一来，解决方法就很明显了，即使用传值。在Python传值需要copy模块。果不其然，使用传值方式后，问腿迎刃而解了。 附正确代码： def yh(): L = [1] yield L while True: L1 = [0] + L L2 = L + [0] L.append(0) for m in range(len(L)): L[m] = (L1[m] + L2[m]) yield L results = [] n = 0 for t in yh(): results.append(t) n = n + 1 if n == 10: break for t in results: print(t) ","date":"2020-06-29","objectID":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/:0:2","tags":["coding","Python"],"title":"python参数传递","uri":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/"},{"categories":["coding","Python"],"content":"战果 ","date":"2020-06-29","objectID":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/:0:3","tags":["coding","Python"],"title":"python参数传递","uri":"/posts/ed/python%E4%BC%A0%E5%8F%82%E5%9D%91/"},{"categories":["coding","basic"],"content":"Python入门 ","date":"2020-06-29","objectID":"/posts/ed/python/:0:0","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"前言 之前对python比较排斥，一直认为是现在的氛围而已，但是昨天用shell创建一些自动化任务的时候，感觉到脚本语言是如此的方便，远比C来的快，那就学学python！！ Python给我的感觉是很类似C，但是在数据类型方面。要优于C很多，不再需要考虑数据类型。也不再需要考虑高精度。 编程语言尽管语法都不尽相同，但是整体思路都是一样的，并且都可以运行在 同一的软件和硬件上。因此相差不会很大的。（架构什么的暂且不去考虑） ","date":"2020-06-29","objectID":"/posts/ed/python/:0:1","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"一些小知识 Python的确是很方便，但是毕竟是一个解释语言，执行速度一般来说是比不上编译语言的 说一下两种语言的区别： 解释语言：有很多，JavaScrip也是解释语言，这类语言拿到的就是一个源文件，不需要编译直接就可以运行，所以就强制开源了。在执行的过程中，还需要解释器一句一句的去解释，解释完之后在执行，相对较慢。脚本语言也是解释型语言的一种。 编译语言：很经典的就是C了，起初先是由编译器将代码编译成exe文件，因为exe是直接编译的二进制文件，因此执行速度会很快。 编码：内存中以unicode表示，硬盘中以UTF-8存储。 python内，除法有两种方式 ​ 方式1：/ 得到的结果是小数 \u003e\u003e\u003e 9/2 4.5 ​ 方式2：//得到的结果是整数（没有四舍五入机制） \u003e\u003e\u003e 9//2 4 变量概念： a=[1,2,3] a=\"Runoob\" 以上代码中，[1,2,3] 是 List 类型，“Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 ","date":"2020-06-29","objectID":"/posts/ed/python/:0:2","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"Python基本语法 ","date":"2020-06-29","objectID":"/posts/ed/python/:1:0","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"输入输出 输入 # 输入 name = input();#括号中可以填写文字，用于提示输入。 值得注意的是：如果在绝大多数语言中，字符串都是需要加引号的。因此input()括号内的字符串也是需要加双引号的（单引号亦可） 例如：input(“请输入：”) 输出 相对于输入，输出就有点小东西了。 print用法 1.没有分号 print() 2.字符串还是需要加引号 print(\"hello world\") 3.转移字符为：\\，初次之外r’‘引号之间的就是需要原样输出的内容，直接忽略各种转义字符 print('I\\'m a boy') print(r\"I'm a boy \\!\\！\") 4.长文本输入（换行）‘‘‘我是内容’’’ 输出结果中：自动换行！默认是字符串格式 类似于多行注释的样子（‘’‘我是内容’‘’） print(''' 我 是 内 容''') 5.格式化输出 print(\"你好：%s\" % (\"ymyguang\")) print(\"亲爱的：%s您好，您的假期余额还剩：%d天！！！！！\"% (\"有光\",0)) # 不在print内，仍然适用； 具体原则就是%s表示占位符，后面的%充当分隔符，（）内是格式化的内容，【当只含一个参数时，括号 可省略】，其他用法和C语言很相似。 ","date":"2020-06-29","objectID":"/posts/ed/python/:1:1","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"数据类型 list（列表） –“可变数组” list如果对比C的话，可以看成是C语言数组的扩充。在C中不同类型的值需要存储在不同的数组内。 而在Python中便不存在这种限制 #使用列表方式：（加中括号 ） listname = [内容1,内容2,等等] list列表内可以存储多种不同的变量或者常量的数据类型。 \u003e\u003e\u003e myinf = [\"有光\",'中国','ymyguang','2020','3.1415926'] \u003e\u003e\u003e myinf ['有光', '中国', 'ymyguang', '2020', '3.1415926'] # 多种数据类型 list的访问更加随意，不但可以正向访列表内容，还可以倒着访问（例如myinf[-1]，就是倒数第一个元素） \u003e\u003e\u003e myinf[0] '有光' \u003e\u003e\u003e myinf[-1] '3.1415926' list增删改查更加方便 # 增加列表内容 \u003e\u003e\u003e myinf.append('biao') \u003e\u003e\u003e myinf ['有光', '中国', 'ymyguang', '2020', '3.1415926', 'biao'] # biao 被加入到最后面 # 插入列表内容 \u003e\u003e\u003e myinf.insert(2,'奥里给') \u003e\u003e\u003e myinf ['有光', '中国', '奥里给', 'ymyguang', '2020', '3.1415926', 'biao'] # 删除列表内容 \u003e\u003e\u003e myinf.pop(1) '中国' \u003e\u003e\u003e myinf ['有光', '奥里给', 'ymyguang', '2020', '3.1415926', 'biao'] # 更改列表内容 \u003e\u003e\u003e myinf ['有光', '奥里给', 'ymyguang', '2020', '3.1415926', 'biao'] \u003e\u003e\u003e myinf[0] = \"遇到困难不要怕\" \u003e\u003e\u003e myinf ['遇到困难不要怕', '奥里给', 'ymyguang', '2020', '3.1415926', 'biao'] ”多维数组“\u0026\u0026嵌套“数组” # 多维数组 \u003e\u003e\u003e lis = [1,2,[3,4],5] \u003e\u003e\u003e lis[2][1] 4 # 嵌套数组 \u003e\u003e\u003e p = [3,4] \u003e\u003e\u003e lis = [1,2,p,5] \u003e\u003e\u003e lis [1, 2, [3, 4], 5] tuple（元组）–“不可变数组” # 使用元组方式 t = (1，3) 元组的注意点： 注意一： tuple和list的区别有下 list存储可变元素，表示方法是中括号 tuple存贮的是不可变数组。表示方式为括号 注意二： ​ 如果元组中只有一个元素，注意后面的分号 \u003e\u003e\u003e t = (1) \u003e\u003e\u003e t 1 # 此时t为数字1 \u003e\u003e\u003e t = (1,) \u003e\u003e\u003e t (1,)# 此时便是元组1 # 其区别就是元组有分号。当然当元组为空的时候，就不需要加逗号了 dict(字典)—”哈希表“ # 表示方法 d = {Key1 : value1, Key2 : value2} # 具体例子 \u003e\u003e\u003e d = {\"one\" : 111, \"two\" : 222} \u003e\u003e\u003e d[\"one\"] 111 顾名思义，字典的目的就是为了方便查询。提高查询速度。于list相比之下，查询的速度不是一个量级。但是消耗的内存空间较大，是一种用空间来换时间的一中存储结构。实现原理类似于哈希表。有一个很形象的例子： 相同的字分别做成列表和字典，目的都是去查找内容，很好想象。字典所占的空间肯定是大的，但是查询的速度是快的，而列表形式其确实很节省纸张，但是查找的速度确实惨不忍睹。在Python中，dict和list的效率也是这样。 实现原理：通过对每个Key的计算，得到一一对应的关系。这个意味着字典中的Key是不能变的，一旦变了，就对应不到指定的内存地址了。但是由于List是可变容器，所以说List不可以当做字典的Key。 一些使用方法 通过字典查值 ''' 方法：dictname[\"Key\"] 即字典后加中括号，中括号内输入要填写的Key ''' \u003e\u003e\u003e d = {\"one\" : 111, \"two\" : 222} \u003e\u003e\u003e d[\"one\"] 111 修改字典对应值\u0026\u0026增加新值 \u003e\u003e\u003e d {'one': 111, 'two': 222} # 修改 \u003e\u003e\u003e d[\"one\"] = 111111 \u003e\u003e\u003e d {'one': 111111, 'two': 222} 删除字典值 \u003e\u003e\u003e d {'one': 111111, 'two': 222} \u003e\u003e\u003e d.pop(\"one\") # pop(\"Key\") 111111 \u003e\u003e\u003e d {'two': 222} set(集合) 这里的集合跟数学中的集合极其相似 。其特征于数学中的集合也很相似 元素无序 元素唯一 支持交并 set使用基本操作 使用set \u003e\u003e\u003e s = set([1,22,222,3,3,2]) \u003e\u003e\u003e s {1, 2, 3, 22, 222} 删除元素 # s.remove(Key) \u003e\u003e\u003e s {1, 2, 3, 22, 222} \u003e\u003e\u003e s.remove(222) \u003e\u003e\u003e s {1, 2, 3, 22} 增加元素 # s.add(Key) \u003e\u003e\u003e s.add(199) \u003e\u003e\u003e s {1, 2, 3, 199, 22} 注意点 # 1.定义是需要set([])，即需要字母set # 2.初始化时，以列表形式 ","date":"2020-06-29","objectID":"/posts/ed/python/:1:2","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"流程控制（IF ,FOR ,WHILE） 流程控制和C中的语法极其相似。这里仅仅说一下区别 C语言中的花括号变成了冒号（英文状态下的） //language:C/C++ if (条件) { 内容 } for () { 内容 } # language:Python if (条件): #括号可省略 内容 #强制缩进 for (条件) : 内容 缩进变成了语法上的一部分：为了使python的代码更统一，因此在Python中的缩进非常严格。 ","date":"2020-06-29","objectID":"/posts/ed/python/:1:3","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","basic"],"content":"函数 首先需要说明的是，Python中如果是调用函数函数之后要加括号的！此外函数的返回值为元组类型 函数传参 def mydef(canshu): pass 默认参数 函数传参可传的类型有很多种，只要是在调用函数的时候直接在括号里使用符号来声明类型，均可在将变量传入到函数内部 def person(name): print(type(name)) person({\"a\":\"ww\"}) # 输出结果：\u003cclass 'dict'\u003e person((1,2)) # 输出结果：\u003cclass 'tuple'\u003e person([1,3]) # 输出结果：\u003cclass 'list'\u003e person(1) # 输出结果：\u003cclass 'int'\u003e person(1,2) # 输出结果：报错(原因：函数只有一个参数，这里传了多个参数) person(\"wd3d\") # 输出结果：\u003cclass 'str'\u003e 此时就面临这一个问题，当我们计算一个数列的的情况下，除了手动封装成元组 之外，还有什么方法？ 可变参数（解释器翻译成元组） 答案是一定有的，我们可以使用：*符号，告诉函数将传入的值，自动封装成元组。 def person(*name): print(type(name)) person(1,2,3) # \u003cclass 'tuple'\u003e 当然我们也可以在传参的同时去将一系列的参数封装成元组类型。 def person(name): print(type(name)) name = (1,2,3) person(*name) # \u003cclass 'tuple'\u003e 关键词参数（必须在赋参数值的时候，写出形变量名称） 接着我们还可以使用两个**去封装成字典。即在关键词参数中，强制写出形参变量名称。 def person(**name): print(type(name)) person(name=\"ah\") # \u003cclass 'dict'\u003e # 输出结果：{'name': 123} # 在多说一下字典，之所以字典前面的是Key，系统默认Key是一个标签，可以使用变量的类型有:整形和字符串。所以使用字符串的时候，字符串需要加引号。 其他注意 \\：表示强制使用位置赋值（实参位置对应形参位置） 迭代器–yield 为了解决列表占用大量内存空间的问题，迭代器就是一种时间换空间的解决方案，迭代器在执行过程中会对类似函数中的代码进行计算，如此一来就节省了空间；下面是yield的特点 特征一：含有return的功能，可以将值返回到调用位置 特征二：会记录“函数”上一次执行的位置，下次迭代时，会从上一个位置继续进行。因此迭代“函数的”内容是会被保存的，而且会记录上一次的执行位置。 ","date":"2020-06-29","objectID":"/posts/ed/python/:1:4","tags":["coding","basic","Python"],"title":"Python入门","uri":"/posts/ed/python/"},{"categories":["coding","problem"],"content":"记一次tomcat乱码的解决方法 起初在是使用tomcat的时候，一脸懵逼不是到是什么。实际上tomcat是由Java编写的服务器软件。 之前在IDEA里面，使用tomcat，但是软件中的控制台中，显示乱码。想了想，怀疑是编码不对称。 在cmd中输入：chcp ，显示936，查询可知，该代码是GBK2312的编码，于是乎打算更改成65001（UTF-8）的编码格式，但是修改的作用域仅仅在当前窗口的cmd，关闭之后还是恢复成默认的936代码 ​ 尝试更改regedit，将CodePage更改成：65001，但是还是乱码。 百度一阵子，得到了解决方案： 在tomcat下的conf中的：logging.properties文件，把其中的 等号后面改成GBK2312，再次启动tomcat，就不乱码了。 问题分析：tomcat在执行的过程中，将默认的编码设置成UTF-8，但是cmd显示的是GBK，因此乱码。 ","date":"2020-06-29","objectID":"/posts/md/tomcat/:0:1","tags":["coding","Java","problem","踩坑"],"title":"tomcat乱码","uri":"/posts/md/tomcat/"},{"categories":["coding","basic","data structure"],"content":"单链表（Java代码实现） 前言 在计算机学习体系中 ，数据结构的地位不可或缺，甚至可以是派头老大哥。 那么什么是数据结构？说人话就是通过代码构建的一中数据关系，实际上数组也是一种数据结构，是最简单的数据结构，除此之外，还包括：链表，栈，堆，队列，树，图，森林。这些名词都很形象的反映出数据之间的关系，每一个数据结构的引用都是为了解决一些特定的问题，例如队列的先进先出的数据特征，可以解决线上排队的功能，总而言之，数据结构在计算机体系中，占有很大很大的分量，尽管目前很多语言已经实现了对数据结构的封装，我们可以直接拿来使用，但是最好还是要知道各自的原理，能够在日常的开发中，更加迅速选择适合开发环境的数据结构。鉴于此，今后更新数据结构系列文章。 ","date":"2020-06-29","objectID":"/posts/ed/%E5%8D%95%E9%93%BE%E8%A1%A8-java%E7%AF%87/:0:1","tags":["coding","Java","data structure"],"title":"单链表","uri":"/posts/ed/%E5%8D%95%E9%93%BE%E8%A1%A8-java%E7%AF%87/"},{"categories":["coding","basic","data structure"],"content":"链表 什么是链表？ 数据结构中的知识众多，今天我们先从最简单的链表来抛砖引玉，是大家知道什么是传说中的数据结构； 首先这是一个链子： 很明显，这一个长长的链子，有很多结，很多的结有相互相连形成了一条链子（这不废话），如果你能看懂，那么恭喜你，你已经学会了数据结构中的链表了，也就是说，到这里，你就可以关了。 嘶嘶嘶，开个玩笑，我们还差一个代码实现就真的可以走啦！ 那么为什么叫链表，而不是叫链子捏?~(￣▽￣)~*，你可以理解成，在计算机中这种链表的数据结构类似于一种表，所以叫他为链表啦！ 跟第一张图片很相似把！！！ 代码实现 创建节点 我们从上面可以知道 ，一个链表需要满足两种条件 节点和 连接；因此在我们的代码实现中，就需要满足以上两个条件 。 //创建节点模板 class Node { int data; //保存数据 Node next = null;// 下一个节点 public Node(int data) { //初始化节点的值 this.data = data; } } 我们可以通过上面的代码去创建一个节点，这里要注意的是，这里我们可以把它理解成模板，当我们需要一个节点的时候，直接实例化即可，这就体现了面向对象的好处了！ 连接节点 在这里，我们只需要节点去指向下一个节点，就要能实现节点的连接。具体如下 Node newNode = new Node(d); // 创建一个新节点 Node tem = head; // 记录首节点 while (tem.next != null) { // 遍历到链表的尾部，如果节点还有指向，就继续遍历，只到最后尾节点 tem = tem.next; } tem.next = newNode; //将尾部指向我们新建立的节点 } 至此，我们的一个链表就建立成功了，当然我们还可以对链表中的元素，进行增删改查，为了吃的太多嚼不碎，今天就先介绍这些。你学会了吗？ 感觉还不错的话，欢迎关注加三连哦!，mua~ 下期预告：单链表的数据操作 ","date":"2020-06-29","objectID":"/posts/ed/%E5%8D%95%E9%93%BE%E8%A1%A8-java%E7%AF%87/:1:0","tags":["coding","Java","data structure"],"title":"单链表","uri":"/posts/ed/%E5%8D%95%E9%93%BE%E8%A1%A8-java%E7%AF%87/"},{"categories":["coding","basic","java"],"content":"问题产生 在看源码的时候，看到了这一句话: List\u003cPerson\u003e personList = new ArrayList\u003c\u003e(); 第一眼看上去并没有太在意，但是再看到这句话的时候，不禁产生了疑问； 通常在定义对象的时候，都是类名 变量名 = new 类名(); 且前面的类名和后面类名是相同的；但是在上面的语句中，前后的类的名字却不一样； 那么能运行成功吗？ 为什么这里前面的和后面的类名不一样？ 带着这些问题，我开始了实验验证 解决过程 !!第一个问题：前面的和后面的类名不一样能运行成功吗？ 我将一下源代码放到了编译器，尝试运行： import java.util.ArrayList; import java.util.List; public class Text { public static void main(String[] args){ List\u003cPerson\u003e personList = new ArrayList\u003c\u003e(); for (int i = 0;i \u003c 3 ; i++){ personList.add(new Person(\"空哥牛逼_\" + i)); } for (Person person : personList){ System.out.println(person.str); } } } class Person{ String str; Person(String str){ System.out.println(str); } } 下面是运行结果： 很显然，这种写法是能够运行成功的，但是,以下的写法也能顺利的运行成功 ArrayLisy\u003cPerson\u003e personList = new ArrayList\u003c\u003e(); 那么就很自然的引出了第二个问题： !!!这条语句为什么不按照【new前后类名相同】的一般写法写？ 由于这个问题不知道怎么验证，就在空哥群寻找帮助，各个大佬都纷纷说出了自己的见解；慢慢的我也开始理解了这种写法的目的；这里引用流水前辈的回答： 前辈说的很清楚，这样写法的目的就是为了能够更好的面向接口编程，而面向接口编程的最终目的是为了解耦。 下面是面向接口编程的一些好处： 便于拓展功能 有利于项目的维护和升级 降低代码之间的关联程度（解耦） 实现者和调用者不需要太多的了解，即可使用 实际上，面向接口编程也就是设计模式中：开闭原则的体现； 其遵循的思想是：对扩展开放，对修改关闭。其恰恰就是遵循的是使用接口来实现。在使用面向接口的编程过程 中，将具体逻辑与实现分开，减少了各个类之间的相互依赖，当各个类变化时，不需要对已经编写的系统进行 改动，添加新的实现类就可以了，不在担心新改动的类对系统的其他模块造成影响。 在中小项目中，也许我们贪图一时之快，没有仔细的分析产品架构并不会给我们带来很大的影响，但是一旦在大项目中，缺少这种编程思想，那么维护起来将“痛不欲生”。就像一流企业做标准，二流企业做品牌，三流企业做产品一样，项目的结构对于整个项目的最终情况起着举足轻重的作用。这有一次反映出做架构的空哥有牛逼！ 对于面向接口编程的介绍，网上很多，在这里就不浪费口舌再展开说了。总而言之，就是为了能够更好的维护和升级项目。 问题总结 List\u003cPerson\u003e personList = new ArrayList\u003c\u003e(); ArrayList\u003cPerson\u003e personList = new ArrayList\u003c\u003e(); 以上两种写法都是可以的，但是第一中写法更好，因为对后期维护项目有更大的好处； ","date":"2020-06-29","objectID":"/posts/md/%E9%97%AE%E9%A2%98%E5%A4%8D%E7%9B%98/:0:0","tags":["coding","basic","Java","编程思想"],"title":"面向接口实例","uri":"/posts/md/%E9%97%AE%E9%A2%98%E5%A4%8D%E7%9B%98/"},{"categories":["coding","algorithm"],"content":"算法中的几种排序 ","date":"2020-06-29","objectID":"/posts/ed/%E6%8E%92%E5%BA%8F/:1:0","tags":["coding","basic","algorithm"],"title":"排序算法","uri":"/posts/ed/%E6%8E%92%E5%BA%8F/"},{"categories":["coding","algorithm"],"content":"前言 尽管现在的各种库很丰富，但是还是有必要学习一些经典的算法，去学习思想。 1.冒泡排序（On^2） 这是最简单的一种排序方法。排序名称很形象。冒泡：越来越大。即每轮循环，把最值传递到指定的位置。就像a\u003eb,b\u003ec，所以a最大。 排序的算法就是：两两比较，得到最值，继而接着向后传递 。直到到达指定位置。至此一轮循环的任务结束。比如说把最大值放在后面（升序），那么就是在一轮的循环种中，每次两两比较，都把大的向后交换，最终大的就会在数组的最后面。**值得注意的是：**当筛选出列表中最大值后 ，下一次循环就无需再去比较最后的值。依次类推； 基本思路步骤如下： for (int i = 0; i \u003c a.length();i++) // 循环次数 for (int j = 0; j \u003c a.length - i;j++) //比较元素位数 if(a[j]\u003ea[j+1]) swap(a[j],a[j+1]) 2.选择排序（On^2） 选择排序跟冒泡排序比较相似。 基本思路：每轮循环取最大的值（或者是最小的值）通过标记坐标的方式，记录最值。循环结束后与 列表首（尾）进行交换；每次循环结束后，所比对的元素少一； 基本步骤 for (int i = 0;i \u003c a.length();i++) max = 0; //从首元素开始比对 for (int j = 0; j \u003c a.length.() - i; j++) if (a[j] \u003e a[max]) max = j; if (i != max) swap(a[max],a[i.length() - i]); 3.插入排序（On^2） 这个排序方式也很形象。算法实现过程类似打扑克牌时的排序。 **基本思路：假设前面的数列顺序是正确的。**先记录自己的值（可以想象成挖坑了），通过和自己前面的数字进行比较，如果前面的数字大于该数字，就将前面的数字向后移动一位（也就是把自己的坑填上；就这样一直比对一直填坑。直到找到前面比自己小的数字，再把该数字放到该数字的后面； 基本步骤 for (int i = 1; i \u003c a.length(); i++){ X = a[i]; j = i - 1; while (a[j] \u003e X \u0026\u0026 j \u003e= 0){ a[j+1] = a[j]; j--; } a[j+1] = X; } 4.归并排序 相比上面三个排序来讲，下面的排序显得更有分量。因此可以在这里学到更多的思想。 归并排序有一个很重要很重要的思想：分治法！ 何为分治法：分而治之。大任务拆解成小任务解决。当每个小任务都解决了，大任务也就迎刃而解了。 其次，二分法是归并排序中所用的“拆解方式”。执行逻辑就是：把大数组分解分解再分解，知道分解到只有两个元素的时候 ，再将两个元素排序，排序完成后，在进行合并。每次合并都是比对子数组第一元素。 基本步骤： // 分函数 Merge(int l,int r,int arr[]) { int mid = (l+r)/2; if (l \u003c r) { Merge(l, mid, arr); Merge(mid+1, r, arr); Sort(l, r , mid ,arr); } } // 本函数采用了递归的方式。首先是左半部分的元素进行拆分，此时函数 重新进入Merge函数，知道l=r（是剩下一个元素）。再去执行下面的Merge函数。此时mid是上一个函数的mid，r也是上一个函数的r.从而保证了左右两组数组的对称性。 // 最巧妙的地方就在于通过先入后出的方式实现了对数组的拆分，这里值得玩味，很巧妙； //合函数 Sort(int l,int r,int mid, int arr[]) { // 说明：都取首地址的作用是比较数组元素 int i, j, index; int t[Max] = {0}; //临时数组 i = l; //其中一个数组的首地址 j = mid + 1; //另外一个数组的首地址 index = 0; //临时数组的首地址 while (index \u003c= r - l){// 需要比对数字个数，也是比对的次数 while(i \u003c= mid \u0026\u0026 j \u003c= r) { // 两个数组内都含有元素时，谁大把谁放到临时数组内； if (arr[i] \u003c arr[j]) { t[index++] = arr[i++]; } else t[index++] = arr[j++]; } if (i == mid + 1) // 当一个数组内没有元素的时候 ，就将另一个数组内的元素拷贝到临时数组中（循序一致） t[index++] = arr[j++]; else t[index++] = arr[i++]; } for (int i = l; k = 0 ; k \u003c= r-l; k++) { //把临时数组中的元素填充到无需的数组中，使之有序。 arr[i] = t[k]; } } PS值得注意的是：归并排序逻辑上是把数组分成子数组。但是考虑到资源的宝贵以及运算速度，在实际上，直接通过传递和读取数组的一定范围的索引编号，来实现分开数组的目的。 5.快速排序（Onlogn） 目前所有排序中，快速排序是速度最快的排序方式，他与归并排序类似，也是利用到了二分思想（注意：二分不是仅仅对半分，而是分两份）。这种排序算法也很奇妙。 快排难的不是思路，难的是确定边界调节（何时跳出函数） 基本思路： 选中一个数组元素为基准，遍历整个数组，把大于该数字的元素放到一侧，小于该数字的元素放到另一侧。在这个过程中，实现了遍历一次数组就能完成。思路也是非常的巧妙。(整个数组整体上被分成了，一半是大于某数字的，一半是小于某数字的。此时就已经初步实现了数组的有序性。) 在再已经大体上有序的左侧数组选中一个基数，重复步骤一 数组右侧重复 步骤一 当右边界小于左边界时，退出循环 基本步骤 QuickSort(int l, int r, int a) { if (l \u003e r) // 边界条件 return 0; int i = l; int j = r; int X = a[l]; // 记录主值 while (i != j){ while (a[j] \u003e= X \u0026\u0026 i \u003c j)j++; // 右指针移动 while (a[i] \u003c= X \u0026\u0026 i \u003c j)i++; // 左指针移动 //交换数字 int t = a[i]; a[i] = a[j]; a[j] = t; } // 主值置位 a[l] = a[i]; a[i] = X; QuickSort(l, i - 1, a); QuickSort(i + 1, r, a); } Q：为什么右指针先移动，而不是左指针先移动？ A：只有先移动右指针才能保证，当两指针相遇时，所值数字小于主值。从而达到了左边都是小于该数字的目的。 ","date":"2020-06-29","objectID":"/posts/ed/%E6%8E%92%E5%BA%8F/:1:1","tags":["coding","basic","algorithm"],"title":"排序算法","uri":"/posts/ed/%E6%8E%92%E5%BA%8F/"},{"categories":["coding","algorithm"],"content":"后记 当然除了以上所说的排序方式之外，还有一些其他的排序方式。例如桶排序，猴子排序（狗头），睡眠排序，等等等等。相信在以后会有更优秀的排序方式诞生。目前来讲，没有绝对好的排序方式，只有根据排序基数大小，数列自然顺序有关系，因此只有结合数据的实际情况才能找到最好的排序方式。 ","date":"2020-06-29","objectID":"/posts/ed/%E6%8E%92%E5%BA%8F/:1:2","tags":["coding","basic","algorithm"],"title":"排序算法","uri":"/posts/ed/%E6%8E%92%E5%BA%8F/"},{"categories":["life"],"content":"汽车基础原理 汽车起步过程中，是由发动机提供动力，通过齿轮之间的相互作用力，带动被动齿轮（轮轴）旋转总而达到了车轮旋转的作用。 因此： 发动机：提供动力，动力的大小通过转速体现。 离合：为了调整发动机转速与轮轴转速的工具。踩离合目的就是将变速箱与发动机之间的齿轮隔离开，此时就可以更换齿轮类型，调整齿轮搭配。 变速箱：就是换挡，改变主动齿轮和被动齿轮类型关系。 换挡的目的：就是改变主动齿轮和被动齿轮关系，利用物理现象，实现自己的目的； 低档：小齿轮带动大齿轮。有劲 高档：大齿轮带动小齿轮。有速度 ","date":"2020-06-29","objectID":"/posts/ed/%E6%B1%BD%E8%BD%A6%E5%9F%BA%E7%A1%80/:1:0","tags":["life","other"],"title":"汽车变速原理","uri":"/posts/ed/%E6%B1%BD%E8%BD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["coding","basic"],"content":"扫盲字符编码 引言 想必大家之前一定 会被字符编码困惑。ASCII，GB2312，Unicode，GB18030等等，或者说大家遇到过文件乱码问题。那么这一系列的编码到底是什么？他们之间又会有什么区别？又为什么产生乱码问题？ 1.背景 大家应该知道，我们现在的计算机都是二进制，在通俗的来讲，就是01构成！那么问题来了。我们人类交流的主要方式是语言，而语言往往是由大量的符号构成的，所以很自然的就会想到使用二进制编码，对应到指定的符号，即一个唯一的编码对应一个唯一的符号。在这里说两个概念； 字符集：一堆符号的集合，里面包含了符号，文字，图形符号，数字，甚至可以是表情包。（对于人的字符集合） 字符编码：一套规则。使一个二进制代码对应到一个符号的规则。一串00101010的代码，规则A就可以把他读成：0010 1010（读取两次），而规则B就把他读成：”00101010“ 细心的读者可能有所发现，没错，上面的那些ASCII等，都有自己的字符集和字符编码，其中字符编码就一一对应自己字符集内的所有内容 2.ASCII 当初计算机是在美国流行起来的，所以当他们考虑计算机显示文字的问题时，想到的肯定只有字母。于是乎，ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）编码便呼之欲出。 下图便是ASCII表（数字代码和符号的对应关系） 具体规则 在ASCII中规定：一个字节所对应一个符号。在计算机中，一个字节包含8位，一个字节所能表示的不同状态也只有：256个()\u003e) 。就像上图：符号A，所对应的数字编码为：0100 0001。 但是需要注意的是在ASCII字符集中，只有128个符号，因此ASCII内，128的对应关系。其中前32个符号，是非显示字符（计算机显示）。 随着计算机的发展到欧洲，由于欧洲人们也有着自己的语言，于是就对ASCII进行了拓展，把剩下的128个也建立了对应关系，来表示欧洲地区的字符，并命名为：EASCII 3.非ASCII编码 3.1GBXXXX字符集\u0026编码 聪明的各位可能就就要问了，欧洲，美洲都把256个对应关系都用光了，我们大中国怎么办？我们博大精深的文字如何表示？此时此刻，GBXXXX字符集\u0026编码就诞生了！（这里的X仅代表数字）。 GB开头的就是我们中国的字符编码。GB就是国标的首字母大写。下面的图是2312的对应规则。 具体规则： 在GB2312中规定：两个字节所对应一个符号。 Q：为什么ASCII一个字节表示，而GB2312用两个符号表示？ A：亲，因为咱们的字多呀！两个字节可以有65536个对应状态（） 3.2Unicode编码 可能又要有人问了，不同国家的字符编码不同，那么如何保证信息的准确性？如果我在中国写好的文档，跑到美国去，那我的文档岂不是要乱了？其实在Unicode没有出世之前的确是这个样子的。随着互联网的出现，全世界的人们都在用自己的语言去共享着信息，如果所使用编码不统一，势必会产生乱码的情况的。 那么只有一个解决方式：将世界上所有的文字都去遵循同一种编码方式。这个方法看样子是不是很难实现？但是他已经被Unicode去实现了，所以Unicode是一个很伟大的编码方式； Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 说人话就是：将世界上所有的符号都纳入其中，并且都有与之对应的关系； （最新的Unicode14.0编码规范要在2021年3月发布，由于疫情故推迟到2021年9月发表。） 3.3 UTF-8编码 在Unicode值得注意的是：Unicode仅仅规范了符号的编码方式，但是对于存储的方式并没有对此说明。 因为有的符号仅需要一个字节，有的需要多个字节。比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。如果全都以：四个字节去存储，由于较小值的编码点一般使用频率较高，直接使用Unicode编码效率低下，大量浪费内存空间。UTF-8就是来解决这个问题的。即解决Unicode存储问题。（后面的8就是以8位为单元进行编码） UTF-8的编码规范： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n \u003e 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 4.结束 至此，计算机表示语言的方式（即编码规范）基本大势已定，绝大多数都是Unicode编码，UTF-8存储。从此以后互联时代得到了飞速发展。全世界人们尽管语言不同，但是表示语言的方式完全统一！使得全球互联，世界互惠，人们互通！故此致敬各位前辈在字符编码上所付出的努力！ 参考文献： ASCII，Unicode 和 UTF-8 By阮一峰的网络日志 UTF-8 By维基百科 字符集和字符编码 By吴秦 ","date":"2020-06-29","objectID":"/posts/ed/%E6%89%AB%E7%9B%B2%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:0","tags":["coding","basic","character"],"title":"字符编码小知识","uri":"/posts/ed/%E6%89%AB%E7%9B%B2%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["blog"],"content":"静态博客、动态博客 ","date":"2020-06-27","objectID":"/posts/blog/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:0","tags":["blog","other"],"title":"博客种类","uri":"/posts/blog/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["blog"],"content":"1、静态博客 都说静态博客比动态博客响应速度快，页面加载速度快 这是为什么？静态博客又是什么？静态博客主要体现在自己的：“静“字。何为静？我们可以理解成不动。对于计算机而言就是对应的：没有进行操作，因此成为静态！ 那么问题来了，一个博客的功能就是展示文章，网站不不进行任何的运算和操作，我们的博客该怎么运行？ 这就说在点子上了，只有我们提前把网站的相关文件准备好，没错是所有的网页提前发布在网站内，当用户直接访问博客时，会通过URL去定位到指定的文件，再有浏览器进行渲染，就得到了所看到的页面了。在这里就已经把静态博客的概念说完了。 静态博客（网站）：提前将网站的内容准备好，提前放到服务器上面。通过URL直接访问指定文件。 （就像我们在Windows系统的资源管理器的地址栏中，直接输入文件就能打开文件一个道理！） 这就可以理解为什么静态的网页加载速度快的原因了！不需要实时的加载，直接就能访问，所以就快了。目前有很多将多种文件直接渲染成HTML的博客框架，其中最有名的要数：hexo。此外很多Hexo+Github搭配可以做出很好效果的静态博客网站（这种教程网上有很多） 再次总结静态网页的优缺点 优点 更简便更安全 访问速度更快 建站成本极低 缺点 如需其他功能需要第三方插件 不太容易上手，对新手不是很友好 操作比较繁琐 功能相比动态博客，不是很丰富 ","date":"2020-06-27","objectID":"/posts/blog/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:1","tags":["blog","other"],"title":"博客种类","uri":"/posts/blog/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["blog"],"content":"2.动态博客 类比静态博客，静态博客的优缺点就一目了然了！ ","date":"2020-06-27","objectID":"/posts/blog/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:2","tags":["blog","other"],"title":"博客种类","uri":"/posts/blog/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["think","gossip"],"content":"独立思考 大脑的的两个系统分工 系统1 ​ 系统1往往偏直觉性的功能，比如我们的人脸识别，听觉等等，这些尽管都需要大量的运算，但是所处理的任务是少量的，但是是快速的。就相当于我们计算机中的GPU，专门负责计算，没有太多的逻辑跳转，因此在计算力方面，领先CPU 系统2 系统2的功能更强，它可以执行多种的任务。但是所处的领域更广，相比之下速度远不如系统1，且更吃力。 ","date":"2020-06-08","objectID":"/posts/think/%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/:1:0","tags":["think","gossip","life"],"title":"独立思考","uri":"/posts/think/%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/"},{"categories":["think","gossip"],"content":"独立思考 什么是 明白了大脑的分工，独立思考的概念就比较好理解了。所谓的缺乏独立思考的能力，无非就是系统2的参与度少。换言之，系统1的思考并称不上独立思考！ 思维定势（惰性）：直接绕过系统2，尽管问题需要思考，但是由于思维惰性，（短路原则）直接使用系统1进行思考 提升独立思考 既然知道独立思考的本质，我们相对而言就比较容易得到提高独立思考能力的方式了。 阅读内容的选择 多接触多学习新的领域的知识，这样不仅可以提高自己，又能在学习新东西的过程中强制的动用系统2 养成批判思维 不要局限于找到的数量，尽自己最大的能力去发现。 批判思维有两种： ​ 弱批判思维：怀疑别人 ​ 强批判思维：怀疑自己 这两种思维方式，都要有，强弱没有主次之分，相比之下，强批判性思维更难养成 阅读方式 阅读中思考 ","date":"2020-06-08","objectID":"/posts/think/%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/:1:1","tags":["think","gossip","life"],"title":"独立思考","uri":"/posts/think/%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/"},{"categories":["network","network"],"content":"V2ray流量流通过程 代理方式为：全局模式，软件将所有的流量均通过V2ray，但是此时还没有传输到远端服务器 路由方式：全局模式，流经到软件的流量不进行特征判断，均使流量通过远端服务器传输。 代理方式：PAC模式，符合PAC的流量将流入到软件内。（此状态时系统决定是否将来流量包出入给软件） 路由方式：绕过大陆，V2ray对流入的流量进行特征判断，当流量目的地属于大陆地区则使该流量走本机，若不符合就走远端服务器 一个推荐的设置方法：系统代理设置为PAC，V2ray流量设置为全局。此方式的效果是只要通过符合PAC的地址，系统就把流量发送给软件，只要是进入软件的流量都走云端。 之前找了很多PAC的规则，但是都是说法不一，自己只好试了一下，这才得到的方法； 在我的软件版本中，使用用户编辑的规则，同步到本地的PAC文件内，会使内容变化，故直接在pac文件内直接编辑即可。 pac规则 @@ -\u003e 排除 || -\u003e 所有域名均走自定义,例如 : \"||baidu.com\", 就代表百度的所有域名均走自定义. 当用户规则无效时，可以直接在pac文件中的任意位置编辑即可。 ","date":"2020-05-23","objectID":"/posts/network/v2ray%E6%B5%81%E9%87%8F%E6%B5%81%E9%80%9A%E8%BF%87%E7%A8%8B/:0:1","tags":["computer","network","software","V2ray"],"title":"V2ray流量流通过程","uri":"/posts/network/v2ray%E6%B5%81%E9%87%8F%E6%B5%81%E9%80%9A%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"C/C++编译过程 在学习C++过程中，遇到了头文件为什么最好是包含.h类型，而不是cpp类型的问题。在寻找结果的过程过，发现是跟语言的编译过程有关，借此机会学习一下C/C++的编译过程 目的就是：将高级语言转换成二进制语言，供计算机执行； ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:0","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"2021年2月24日更新 ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:2","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"C语言运算规则 语句运算顺序：符号优先级，结合方向 算术运算符结合方向：从左往右 赋值运算符结合方向：从右往左 逗号的值是最后的的值：左结合 运算之后的数据类型，当运算变量数据类型不符是，类型低的自动转换成内存占用高的，（强数据转换），在C中的强数据转换采取：舍去原则；强数据转换是中间值，不印象原来的数据 int/int -\u003e int int/float -\u003efloat %的操作数是整数，符号和被除数一致 // 所有单位运算都是从右往左算的 ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:3","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"C程序的调试过程 编辑 .cpp ,c 源程序文件 编译 .obj 目标文件 链接 .exe 可执行文件 执行 ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:4","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"2020年6月28日更新 前几天我尝试在vs code中，编写多文件的代码文件，但是出现了很多报错情况，经过排查发现，vsc在没有build system的情况下只会编译当前文件，这就导致了多文件没办法被编译，所以当只有这一个编译好的程序文件去尝试连接代码中不存在的变量时，肯定是找到不到的，就爆出了错误。 那么如何去解决在vsc多文件编译的情况？方法是：上文提到的build system（构建系统），目前流行的时：cmark，它可以根据编写规则，生成makefile，之后在去按照makefile去批量编辑多个文件，如此一来，第四阶段的链接才能生效。 多说一句，现在很多都是IDE解决一切，什么都不管直接小三角号，一个三角号就一劳永逸了，时间长了根本无法了解编译的过程，因为所有的东西都被IDE给办了，自己什么都不知道！编程而言，不应该仅仅在表面上 ，还要知道背后的原理，这样才能更容易理解新东西！ 过程 1.预处理 替换代码中的头文件，宏定义，去除代码注释 gcc -E text.cpp -o text.i -E：预处理完成后终止编译进行 2.编译 此过程中会将预处理之后的代码，翻译特定的汇编代码，通常情况下，当编译器报错语法错误时，就是在这个过程中。 gcc -S text.cpp -o text.i -S：编译完成后终止编译进行 3.汇编 显而易见，就是把上一步转换到的汇编代码，翻译成机器语言 gcc -c text.cpp -o text.o -c：汇编完成后终止编译进行 ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:5","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"4.链接 在C/C++中，一定少不了对头文件的引用，当编译器把自己的cpp编译以后，还会链接到cpp中的头文件所对应的,obj文件，如此以来，整个程序才被编译成了可执行文件。 附表： 文件扩展名 文件类型 .c C语言代码 .C、.cc、.cpp C++语言代码 .i 预处理后的C语言代码 .s、.S 汇编语言代码 .o 目标代码 .a 静态链接库(程序编译时使用) .so 动态链接库(程序运行时使用 回到上面的问题： Q：为什么最好是包含.h类型，而不是cpp类型的问题? A：当我们的头文件是cpp文件时，有如下弊端： 当代码文件进行修改后，整个项目都需要重新编译，而当头文件是.h的时候，尽管修改了源代码，但是编译的还是那些代码量，不会在对头文件进行重新编译，之后直接就将编译出来的obj文件，与头文件对应的lib文件进行结合即可。（当整个项目不是很大的时候，二者没有太大的区别，但是当项目大时，这种优势就会很明显了） 当以.h为头文件时，我们就可以很容易的实现库的传播，又能保证代码的闭源。 include \u003c.cpp\u003e 对***.cpp文件重新编译，之后将二者连接 。** #include\u003c.h\u003e 对.h对应的文件名实现连接。* ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:6","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding","C/C++"],"content":"再理解： C/C++编译方式是：单元翻译，独立的编译每一个cpp文件，例如a.cpp，b.cpp在同一个项目文件中，因此在编译整个项目的过程中，编译器会独立的编译a.cpp，b.cpp。但是当b.cpp中，，有一个a中的函数，直接引用了a中的函数，此时编译器会不会报错？实际上是不会报错的，只要我们在b.cpp内声明了这个函数，编译器在编译b.cpp的时候，就会生成一个符号表（symbol table）【b中看不见的变量/函数/类等都会存放到这个表格内】，此时编译器在编译完成后，在链接的阶段就会按照符号表中的值对整个项目进行查找。从而实现了源码分离。 通常，在一个 C++ 程序中，只包含两类文件—— .cpp 文件和 .h 文件。其中，.cpp 文件被称作 C++ 源文件，里面放的都是 C++ 的源代码；而 .h 文件则被称作 C++ 头文件，里面放的也是 C++ 的源代码。 C++ 语言支持\"分别编译\"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件 a.cpp 中定义了一个全局函数 \"void a(){}\"，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件 b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。 这是怎么实现的呢？从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 \"void a()\" 函数之前，先声明一下这个函数 \"voida();\"，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 \"void a()\" 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。 注意这里提到了两个概念，一个是\"定义\"，一个是\"声明\"。简单地说，\"定义\"就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而\"声明\"则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。定义的时候要按 C++ 语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？ 这种机制给 C++ 程序员们带来了很多好处，同时也引出了一种编写程序的方法。考虑一下，如果有一个很常用的函数 \"void f() {}\"，在整个程序中的许多 .cpp 文件中都会被调用，那么，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。一个函数还好对付，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？能保证每个程序员都可以完完全全地把所有函数的形式都准确地记下来并写出来吗？ 贴一下链接：https://www.runoob.com/w3cnote/cpp-header.html 讲的很清楚！！！ 参考链接： 编译器的工作过程 C语言编译过程详解 C/C++程序编译过程详解 ","date":"2020-05-09","objectID":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/:0:7","tags":["coding","C/C++","Tip"],"title":"C/C++编译过程","uri":"/posts/coding/c++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"categories":["coding"],"content":"函数重载，内敛，默认参数值 ","date":"2020-04-28","objectID":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/:0:1","tags":["coding","C/C++","basic"],"title":"函数重载，内敛，默认参数值","uri":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/"},{"categories":["coding"],"content":"重载 在C++中，两个函数的名称可以相同，编译器可以通过形参的个数，类型进行判断调用哪一个函数； 重载函数就是名字完全一样，但是参数类型、个数或者顺序不一样的函数。重载函数主要用来对付不同类型的数据。 ","date":"2020-04-28","objectID":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/:0:2","tags":["coding","C/C++","basic"],"title":"函数重载，内敛，默认参数值","uri":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/"},{"categories":["coding"],"content":"默认参数值 默认参数值就是在定义函数的同时给参数赋值。使得参数有初始值。 注意，在使用默认参数值时，只能从函数的右端进行初始化操作，在给含有默认参数值的函数传值的时候，只能是从左往右传值 // 定义 int f1(int x, int y ,int z = 1)//这里就是所说的：从右往左进行初始化 int f2(int x = 1, int y, int z )//这里就是错误的示范 // 传值 f1(1,1) 因为z含有默认值，所以这里可以传递两个参数 f1(1, 1, 1)// 亦可 f1(, 1)// 这里的传值没有从左往右开始，因此会报错 ","date":"2020-04-28","objectID":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/:0:3","tags":["coding","C/C++","basic"],"title":"函数重载，内敛，默认参数值","uri":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/"},{"categories":["coding"],"content":"内敛函数 inline 目的：解决系统的开销 原理：将inline函数的代码块直接拷贝到调用处。省去了普通函数先从寄存器存值，流程跳转的过程，从而提高了程序效率。 缺点：增加程序的大小 注意：，因此在使用内敛函数的时候，往往是那些：频繁使用且代码量较小的函数 此外：内联函数的处理实在编译器预处理的过程，并且编译器 有权利判断是否 执行内敛操作（编辑器尽自己最大努力去拷贝函数，但是不一定能成功） ","date":"2020-04-28","objectID":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/:0:4","tags":["coding","C/C++","basic"],"title":"函数重载，内敛，默认参数值","uri":"/posts/coding/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/"},{"categories":["coding"],"content":"指针变量和变量指针 ","date":"2020-04-27","objectID":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/:0:0","tags":["computer","C/C++","basic"],"title":"C++中指针变量和变量指针","uri":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/"},{"categories":["coding"],"content":"读法规则 原则一：谁在前先读谁；const int a这里的a就是：常量（const）指针（)。同样：int * const p 这里的p就是指针（）常量（const）* 原则二：变量的类型是谁靠近变量名最近，该变量就是改类型，比如说上面的a，距离*近，所以a就是一个变量 ","date":"2020-04-27","objectID":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/:1:0","tags":["computer","C/C++","basic"],"title":"C++中指针变量和变量指针","uri":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/"},{"categories":["coding"],"content":"变量特征 常量指针：const int p -\u003e const int ( *p) ,要知道，在C/C++中， 与变量结合的左右是“解引用”，其值就是该变量所存地址的值，再加上前面的const，我们可以知道：是对p指针所指向的内存中的值为常量。** **指针常量：int＊const p -\u003e int * const (p)这里括号中是：P，则是对p的值进行添加常量属性，也就是说：p指向的位置是常量，不可变，而所指向的地址中的数值是可以改变的。**常见的p++在这里就不能实现，因为p++就是p=p+1，而这里的p是指针，但是指针是常量所以不可以对p的值进行修改； 常指针常量：const int const p ,如上，这里的P所指向的内存地址，以及内存地址中所指的值都不会发生改变（常量）* ","date":"2020-04-27","objectID":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/:2:0","tags":["computer","C/C++","basic"],"title":"C++中指针变量和变量指针","uri":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/"},{"categories":["coding"],"content":"变量在内存位置分布情况：便于理解； ","date":"2020-04-27","objectID":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/:3:0","tags":["computer","C/C++","basic"],"title":"C++中指针变量和变量指针","uri":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/"},{"categories":["coding"],"content":"代码： #include \u003ciostream\u003eusing std::cin; using std::cout; using std::endl; int main() { char a[3], b[3]; char* const p = a; *(p++) = 'b';//在这里：p是const类型，所以p++会报错 p[0] = 'a'; p[3] = b[0];//这里的b[0]没有初始化，会报错 return 0; } ","date":"2020-04-27","objectID":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/:4:0","tags":["computer","C/C++","basic"],"title":"C++中指针变量和变量指针","uri":"/posts/coding/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/"},{"categories":["coding"],"content":"数据转换 在做C语言题目的时候，有遇到了数据转换类型的题目。之前对这方面总是草草代过，今天终于给我了当头一棒。 现在对该数据类型转换总结整理一下 自动数据转换 将一种数据类型付给另一个数据类型的时候 float f = 100; 这里f是float类型，而100确实int类型，此时编译器会自动把100转换为float类型。 int i = f; 这时候，编译器就会把f转换成int类型，之后在进行赋值操作。 不同类型数据运程中，规则如下 编译器会自动把所占内存小的变量类型转换为所占内存多的数据类型，如图所示 强制数据转换 非自动转化，而是按照自己的需求制定转换类型 规则：(type_name) expression 例如 k = (char)a； 实例： #include \u003ciostream\u003eusing namespace std; int main() { int a = 10,b = 3; double c = (double)a/b //此时仅仅将a转换成double类型，就可以是编译器自动将结果转化成double类型变量 } PS：转换数据类型都是临时，并不印象元数据的值！ ","date":"2020-03-04","objectID":"/posts/coding/c%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/:0:1","tags":["computer","C/C++","basic"],"title":"C++中的数据转换","uri":"/posts/coding/c%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"},{"categories":null,"content":"思科—网络安全笔记 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:1:0","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"目录 [TOC] ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:2:0","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"漏洞 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:3:0","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"漏洞的分类 软件漏洞 硬件漏洞 1.缓冲器溢出：软件写数据的时候，超出数据区的边界 范围，导致访问到其他软件的内存数据，可能产生的后果有：系统崩溃，权限提升，数据受损等。 2.未验证输入：在程序输入的入口，恶意者故意输入可以强制改变软件内存分配和异常的缓冲区 3.竞争条件：当软件的输出一依赖于：定时或者是有序时，当未按照正确的顺序或者是正确的时间定时输出时，竞争条件成为漏洞的来源 4.安全验证：软件设计者在自己的程序中使用自己做定义的加密算法，而不是使用公认的加密时，可能会导致加密算法被破解。 5.访问控制问题：控制谁做什么的过程。包括物理访问控制，资源的权限，读取或者是更改文件的权限 许多的漏洞是由：不当的访问控制导致的 6.物理破坏 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:3:1","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"恶意软件malware的类型 间谍软件：跟踪侦察用户，例如记录键盘，数据捕获等 僵尸软件：构成僵尸网络，为攻击者提供资源 广告程序：投放广告 勒索程序：强制用户解密本机数据，达到勒索的目的 假冒安全软件：通过假官方的提示，欺骗用户安装没必要安装的程序或指令 rootkit:专用于修改系统达到植入后门的目的，大多数rootkit利用软件漏洞，提上自身权限，修改系统设置和检测工具 病毒：附加到软件当中的，随着程序一起运行 特洛伊木马：通常隐藏在图片，游戏，音频中。 蠕虫:利用网络中的漏洞自我复制的恶意代码，不像病毒，蠕虫可以自己运行而不需要“宿主”最大特点，自我复制. 中间人（Mitm）：在中间截取用户的信息，然后在传达用户预先访问的位置 移动中的人：中间人的变种，主要目标是移动设备的攻击，软件：zeus ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:3:2","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"恶意软件的症状 无论系统感染了哪种恶意软件，以下是共有的恶意软件症状： CPU 使用率上升。 计算机运行速度变慢。 计算机时常死机或崩溃。 网络浏览速度变慢。 网络连接中存在无法说明的问题。 文件被修改。 文件被删除。 存在未知文件、程序或桌面图标。 有未知进程正在运行。 程序自行关闭或重新配置。 在用户不知情或未经用户同意的情况下发送邮件。 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:3:3","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"渗透方法 社会工程 WiFi破解 网络钓鱼 漏洞利用：收集信息-\u003e利用信息-\u003e发现漏洞-\u003e利用漏洞 拒绝服务 DOS拒绝式服务攻击 大量流量：大量的流量导致系统崩溃 恶意数据包：例如不当的数据格式，导致系统崩溃 DDOS分布式拒绝式服务攻击 —僵尸网络构成 SEO（搜索引擎优化）中毒 恶意使一个恶意网站在搜索前页，排名更高！ ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:3:4","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"消减影响 1.公司承认错误 2.提高详细的信息 3.确保系统干净，没有后门 4.总结经验 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:3:5","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"隐私保护 保护计算机设备 启用防火墙 安装安全软件 调整计算机安全设置（安全等级） 设置密码保护，密码等级越高越好！ IoT局限于固件的低频更新性，容易受到攻击，避免方式：使IoT独立网络，仅与其他IoT共享 无线安全 信息加密 加密时将信息转化成另一种信息形式 加密文件系统：EFS 开放授权OAuth2.0 是一种开放授权协议，第三方授权。例如：QQ在线登录酷我音乐的网站 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:4:0","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"保护组织 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:5:0","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"防火墙类型 网络层防火墙：对IP筛选，审查IP 传输层防火墙：端口过滤 应用层防火墙：应用，服务过滤 情景感知防火墙：对用户、设备进行审查筛选 代路服务器：对Web请求过滤 反向代理服务器：反向代理服务器位于 Web 服务器的前面，用于保护、隐藏、分流和分发对 Web 服务器的访问 网络地址转换器(NAT) - 隐藏或是伪装主机的专用地址 基于主机的防火墙 - 过滤单个计算机的端口，服务等； ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:5:1","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"端口扫描 在网络中，设备上运行的每个应用都分配有一个标识符，该标识符叫做端口号。 作用：此端口号在传输的两端使用，以将正确的数据传递到正确的应用 三种状态：打开，关闭，无答复 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:5:2","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"防御方法· 相关名词 CSIRT - 安全事件响应组织 IDS - 入侵检测系统：基于规则或者恶意攻击数字签名扫描数据，只能通知网络管理员，仅仅提供检测功能； ​ 由于扫描会降低网速，因此离线使用（交换机将数据转达给IDS进行离线扫描） IPS - 入侵防御系统：能够根据主动原则或签名匹配阻止或拒绝流量 SIEM - 安全信息和事件管理系统：一种用于收集和分析来自网络上的安全设备的安全警报、日志及其他实时和历史数据的软件。 ","date":"2020-03-03","objectID":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/:5:3","tags":["computer","network","note"],"title":"思科—网络安全笔记","uri":"/posts/network/%E6%80%9D%E7%A7%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"categories":["network","Ops"],"content":"SSH原理（非对称加密） 什么是SSH？ ​ SSH是一种协议标准，通常用于主机之间的加密通讯，SSH之前，互联网通讯传输的数据是以明文传输的。 加密 对称加密（私钥加密） 加密使用同一种密钥，此加密方式，在传输过程中能保证信息很难被破破解，但是有一个致命的确定：很难保证密钥不被泄露。原因是：把自己的密钥放在很多服务器上，一点其中的服务器被攻破，那么与其他的服务器通讯时，采用同一种密钥，此时，信息将被泄露。此时产生了：非对称加密； 通讯过程 本地通过密钥加密，发送至服务端 服务端的到信息后，按照同样的密钥解密 ","date":"2020-02-24","objectID":"/posts/network/ssh%E5%8E%9F%E7%90%86/:1:0","tags":["SSH","network","basic"],"title":"什么是SSH","uri":"/posts/network/ssh%E5%8E%9F%E7%90%86/"},{"categories":["network","Ops"],"content":"非对称加密（公钥加密）： 公钥加密，私钥解密。私钥解密，公钥解密，也称公开密钥加密 如果你问我，哪一种算法最重要？ 我可能会回答“公钥加密算法”。 来自:阮一峰的网络日志 此加密方式产生两个密钥，一个是公钥，一个私钥。两者关系：公钥加密后的密文，只能通过对应的私钥进行解密。 验证方式 为了防止中间人攻击：攻击者将自己的公共密钥发给客户端，客户端通过此公钥加密后的信息，将被攻击者的私钥解密，如此一来就会导致信息的泄露。所以采取一下验证方式。 1.密码验证 通讯过程： 1.本地段发送数据请求，服务端收到后，将该服务器的公钥发送给服务器 2.本地端收到该密钥后，账号和密码进行加密，加密完成后，发送给服务端 3.服务端收到客户端通过公共密钥的信息，通过在本地于该公共密钥对应的私钥，进行解密，账号密码后，与服务器内的值核对校验 4.当身份验证成功后，将数据返回到客户端 但是弊端是，攻击者可能会采取暴力破解的方式，对密码进行猜解，相对密钥验证方式，被破解的概率较大，原因是，通常情况下，密码的程度达不到密钥的复杂程度。 2.密钥验证 该验证方式首先要求，客户端将本地的公共密钥放在远端 当服务器收到客户端的请求时，服务端会生成一个随机数并匹配该用户上传的公钥，对该随机数R加3密。加密之后发送加密数据到客户端 客户端收到加密信息后，通过自己的私钥，进行解密，得到随机数R，并且将R与会话密钥通过MD5生成摘要，再次发送至服务端 服务端收到该MD5后，也会对自己产生的R和会话密钥生成MD5摘要，继而匹配两个MD5 MD5相同时，建立起此次通讯 RSA算法：非对称加密算法的一种 1.什么是RSA加密 RSA是一种非对称加密的加密方式，加密得到的结果1024位，或者是2048位。 在保证加密的安全性的同时，也导致加密过程相对较慢，不适用于多信息的加密过程。 为啥子叫：RSA，闪开，大佬来袭： ","date":"2020-02-24","objectID":"/posts/network/ssh%E5%8E%9F%E7%90%86/:1:1","tags":["SSH","network","basic"],"title":"什么是SSH","uri":"/posts/network/ssh%E5%8E%9F%E7%90%86/"},{"categories":["network","Ops"],"content":" 因为RSA是由：三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，因此叫做；RAS！ 毫不夸张的说，由计算机的地方就有RAS加密算法。 ","date":"2020-02-24","objectID":"/posts/network/ssh%E5%8E%9F%E7%90%86/:1:2","tags":["SSH","network","basic"],"title":"什么是SSH","uri":"/posts/network/ssh%E5%8E%9F%E7%90%86/"},{"categories":["network","Ops"],"content":"原理 呃。。。。待更吧。。 ","date":"2020-02-24","objectID":"/posts/network/ssh%E5%8E%9F%E7%90%86/:1:3","tags":["SSH","network","basic"],"title":"什么是SSH","uri":"/posts/network/ssh%E5%8E%9F%E7%90%86/"},{"categories":["coding"],"content":"C++相比C中的改进 for循环 C++中的For循环变得更加简洁，对For进行了扩增，就像Python中的for一样； int a[] = {1,3,4}; for (auto i : a){ cout \u003c\u003c i \u003c\u003c endl; }//输出结果就是a中的值，其过程就是将a中的所有元素依次赋给i，之后输出i。 for (auto \u0026i : a){ cout \u003c\u003c i \u003c\u003c endl; }//对数组a中的值进行直接操作，此时for的先决条件变成了：auto \u0026i ,也就是将a中的元素的地址给i，或者是说，i在每次循环的过程中，就是a元素的地址 示例代码： #include \u003ciostream\u003eusing std::cin; using std::cout; using std::endl; int main() { int a[] = { 1,2,4,4 }; for (auto i : a) { cout \u003c\u003c i \u003c\u003c endl; } for (auto\u0026 i : a) { i = 2 * i; } cout \u003c\u003c endl; for (auto i : a) { cout \u003c\u003c i \u003c\u003c endl; } return 0; } ","date":"2020-02-04","objectID":"/posts/coding/c++%E7%9B%B8%E6%AF%94c%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B/:0:1","tags":["computer","C/C++","basic"],"title":"C++相比C中的改进","uri":"/posts/coding/c++%E7%9B%B8%E6%AF%94c%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B/"},{"categories":["coding"],"content":"If and Switch Statement with an Initializer Why add an Initializer in If anf Switch? The variable, which ought to be limited in if block, leaks into the surrounding scope (本应限制于if块的变量，侵入了周边的作用域) The compiler can better optimize the code if it knows explicitly the scope of the variable is only in one if block (若编译器确知变量作用域限于if块，则可更好地优化代码) ","date":"2020-02-04","objectID":"/posts/coding/c++%E7%9B%B8%E6%AF%94c%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B/:0:2","tags":["computer","C/C++","basic"],"title":"C++相比C中的改进","uri":"/posts/coding/c++%E7%9B%B8%E6%AF%94c%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B/"},{"categories":null,"content":"recursive（递归）的一些理解 Recursive难以理解的原因在于：多次调用函数后，无法想象到执行流程，无法在代码成面上直观的观察。 不过还是有一些技巧来形思考递归的特点； 以下是递归的关键 1. 边界条件（返回的依据） 2. 返回时运算语句 在递归中，需要注意的是：真正的运算是在达到递归条件的边界后，再利用多层嵌套的return的语句，执行递归内容。每一次递归的结果供前一个调用函数使用，以此类推；另外，由于递归调用的是自身函数，因此可能会面临变量重名的问题，实际上在每次调用的时候，重名变量仅仅是在当前所在的范围内起作用，即便是函数外还有与之重名的变量，但是没有任何影响。并且当一个递归的某一流程结束后，当前函数内的任何变量都会被释放（堆空间除外） 直观的表示： 一个例子： 很多程序都可以改成递归的形式，但是递归需要大量的空间，因为需要不同的调用。 下面是一个阶乘使用递归的例子：（上图就是这个例子的图示） ","date":"0001-01-01","objectID":"/posts/algorithm/recursive%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:0:1","tags":null,"title":"","uri":"/posts/algorithm/recursive%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":null,"content":"C++中关于引用位置的一些说明 引用的基本概念：引用实际上就是一个变量的别名。也仅仅是一个变量的别名。 当定义一个引用时，甚至没有创建任何新的变量？（存疑）。在底层上。是有将被引用变量的地址放到引用变量所在地址中的操作。换句话说：创建引用变量在底层是由相关的操作的。但是由于编译器的优化，所显现出来的现象就是：引用变量的内存地址和被引用变量的内存地址是一致的。（其实在物理层面并不是相同的，不是向宏定义那样，在预处理阶段就完成替换）另外，int a = 1；所谓的在内存中申请一个叫做A的内存空间这种说法 也是不准确的。实际上是由编译器将二进制的1放到以A为地址的内存中去； 新定义的变量完全可以当作之前的变量使用。甚至引用变量的内存地址都与被引用的变量地址相同。因此直接编辑新的变量和直接操作原始变量没有任何区别 但是引用变量的在赋值符号（=）的左右位置有着不同的意义和使用方法。 当引用变量在左边时，即： int number = 2; int \u0026refVal = number; refVal = 222; // 等价于：number = 222; 以上是很记住的，也比较容易理解。无非就是修改原始变量； 当引用变量在右边时,即 int number = 2; int \u0026refVal = number; int x = 0; x = refVal; // 这里的refVal实际上也就等同于number的存在，这条语句就是一个简单的赋值 其实在原理上肯定有相关的原因（这就是可以所问的问题）所涉及到的知识就是：C语言在内存的分配情况 ","date":"0001-01-01","objectID":"/posts/c++/c++%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/:1:0","tags":null,"title":"","uri":"/posts/c++/c++%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"英语翻译单词替换 原始单词 替换单词 main primary ","date":"0001-01-01","objectID":"/posts/english/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/:0:1","tags":null,"title":"","uri":"/posts/english/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"编程方面，对于新知识的处理方式 拿到一个新东西，里面可能有很多自己之前没有接触的东西，因此这种情况在生活中还是很常见的；首先要说的是，这里说的知识是泛指的，也许一项技能也可以称之为知识，甚至一个工具也可以称之为一种知识；所以在这里判断知识的基本准则就是：可以解决实际问题，因此下方统称之为知识； 如何能够快速的进行这个项目？现在的做法是： 拿到一个新东西，总是想去一次全部掌握所有内容，于是乎就去花费大量时间去了解新的知识，由于直接接触到一大堆东西，导致会很乱，从而无法进行，接着就是对新知识的恐惧；如此看来这个做法如此看来，不仅浪费时间有没有效率；那么对于解决：**所作任务中有新知识领域，应该怎么解？**就目前来讲，直接一股脑地去想直接把他掌握，这种做法实际情况证明了是不可取的； 对于这个问题，只有面临新，才会有解；那么不妨先着眼于新的方面，再去考虑如何解的角度尝试去分析； ","date":"0001-01-01","objectID":"/posts/think/%E7%BC%96%E7%A8%8B%E6%96%B9%E9%9D%A2%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/:0:1","tags":null,"title":"","uri":"/posts/think/%E7%BC%96%E7%A8%8B%E6%96%B9%E9%9D%A2%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"新 对于新知识(技能)的存在而言，它既然被使用，绝对是有存在的目的，那么就会很自然的考虑道：这项新知识在这里的目的是什么，即，这里用到它，想解决什么问题？。实际上不论是知识、技能、又或者是其他未曾掌握的事物，绝大多数情况下，绝不仅仅只存在一种功能，也即是说某项东西的用处不止一种，那么就面临着一个新的问题：当前是去掌握该项知识的所有用法，还是去掌握当前在此处的用法？很显然理想情况下，我们能把当前知识的所有用法全部掌握是最好的，但是面向完全不了解的知识，直接去尝试掌握所有用法，有很不现实；那么综上所说，还是**==首先学会该知识的当前的使用方法==**既节省时间，还能提高效率； 总结一下： 解决了那些问题 新在哪里 有什么特征 ","date":"0001-01-01","objectID":"/posts/think/%E7%BC%96%E7%A8%8B%E6%96%B9%E9%9D%A2%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/:0:2","tags":null,"title":"","uri":"/posts/think/%E7%BC%96%E7%A8%8B%E6%96%B9%E9%9D%A2%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"解 就像新，当前知识既然用在这，就有用，要么是必不可少的，要么不是必须的，方便了那些流程？优化了哪些问题？这就是他的存在意义；说白了，就是该知识和整体的关系； 知道了关系之后，就看如何使用，最起码的是在当前环境下，如何去使用？尽管知识能够解决的问题有很多，但是 ","date":"0001-01-01","objectID":"/posts/think/%E7%BC%96%E7%A8%8B%E6%96%B9%E9%9D%A2%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/:0:3","tags":null,"title":"","uri":"/posts/think/%E7%BC%96%E7%A8%8B%E6%96%B9%E9%9D%A2%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"},{"categories":["think","gossip"],"content":"【2021年4月18日 随笔】一些思考 [TOC] 前言 昨天去蹭选修课，是一个叫做大数据应用的课程。下课后，有和朋友聊了一段时间（扯皮），收获还是不小的，不仅包括知识上的，还有对于交际，生活，以及学习方面的一些心得；扯皮过程中，朋友给我说的一句话，直触动我的灵魂。 ​ 也许你在人多的时候不愿意出风头，在该表现的时候不去表现自己，尽管当时很安逸，但是死的只是你自己； ​ 这句话感觉跟自己现在的感觉很相似；小时候，认为这个世界真的好美好，每个人都充满着善意，整个社会对弱者的保护是无微不至。但是随着年龄的长长大，我不知道是我看清了社会还是被浮躁的环境蒙蔽了双眼，不知为何是种感觉到这个社会变得残酷起来？越来越发现现在是一副弱肉强食，赢家通吃的局面；曾经所体验到的安逸，跟其他的因素也许有一定的关系，但是主要原因绝不是社会的弱者的眷顾，实际上是背后的父母在承担着一切；在这个社会上毫无真正同情可言，不会可怜任何人。而所谓的善意，只不过是那些资本家所吃下的残羹剩饭而已。反而却能显得他们很博大，很有善心。但其实正在想法设法剥削每一个人；弱者只会变得更弱，强者会不断变强，阶级固化会变得越来越严重。天下熙熙皆为利来，天下攘攘皆为利往；因此不要时常幻想着哪一天可以被幸运之神眷顾，现在唯一要做的好像只有让自己变强唯一的出路； 此外在以下几个方面也有一些收获，这里分别都记录下来； 一、交际 ​ 这个社会强者很多，我们绝不是在某一方面有着突出天赋的人，因此保持沉默，等待着机会找到自己的想法是很天真的，或者说说白了就是一种逃避，是一个天方夜谭的想法；所以自己必须要做的就是主动的向比自己强的人抛出橄榄枝，建立联系，扩大交际圈，这才是最正确，也是唯一能做的方式。同时主动的目的不仅仅是为与老师和同学建立一个友谊关系，最核心的问题还是能解决问题，或者是商讨问题 我认为主动能有这些好处： 第一个便是能够锻炼自己的交际能力，这种能力自始至终我都认为是必不可少的。而且能力越强对自己越有好处，尽管好处不是立竿见影的，但是自己能从中获得的收获绝对是不可估量的； 其次是能与别人建立一个良好的关系，在以后的学习过程中，甚至是生活过程中，都能够寻求帮助 再者，可以扩大眼界，类似滚雪球一样，认识一个人在一般情况下，往往可以通过这个人去认识更多的人。往往一个看似不足为奇的人，在关键时刻也可以帮上大忙 所以说多认识一个人，绝对不是坏事，主动交际，保持可持久化的联系，扩大交际范围； 二、方向 ​ 自己的对方，也是没有一个清晰的认知，到底是工作还是考研？This is a question。现在已经有了答案；考虑到自己的本科学校狠拉跨，再加上家里的期望，包括我认为学历决定上限这个认识，我决定考研；因为本科学校不好，因此只要是考，就要考像样的学校；要不然就是浪费时间；目前是大二，现在直接学习考研科目，时间尚早，所以把考研设为远景目标，近期的任务还是能尽其所能学习一些专业知识，能多做项目就多多一些项目。还有就是拿证，当下要说最紧急的就是英语四级了吧； ​ 所以当下的目标或者说是任务，也还比较清晰的；备考四级，学习专业课，搞项目，打比赛；如果说学习基础课知识是在考研战场上的填充弹药，那么现在做的就是制造决胜武器，初试一定会遇到瓶颈，因此现在做的就是在另一个瓶子内，增加内容； 三、品质 ​ 宿舍一个同学，很令我佩服。只要打算干什么，就一定能坚持下来。不论是什么时候，都知道自己该干什么，这种品质很值得的我去学习；还有就是有关比较的一些看法；**千万不要把自己的缺点跟别人的优势去比较，这不是一个正常的比较方式，甚至是自虐的倾向；**理性的比较是很有好处的，不仅能发现自己的短处，还能找到学习的榜样，一举两得。而万万不可再比较时候，陷入陷入自我怀疑，甚至自卑，妄自菲薄。如果非要这样，那还不如不去比较；这些东西都是论语中的所说的：择其善者而从之，择其不善者而改之；具备这个能力，是一个很可怕的强大。明明对的话，知道对，也知道能从中获利，为什么就是做不到呢？我认为问题有以下三点： 缺乏承认自己缺点的胸襟 没有善于发现别人闪光点的习惯 没有认真思考的过程 那么解决方式就显然易见了； ​ 再有就是自己的品质，需要更加自信，同时也需要更加沉稳，自信和沉稳绝不是一个矛盾。二者相辅相成的。只有有信心在会沉稳；开朗，沉稳、自信、皮实这些关键词在我曾经的理解中，都是矛盾的，开朗怎么沉稳？沉稳踏实有怎么能开朗，善于言谈？我现在尝试着去回答这些关键词； 首先，这些关键词绝对不是矛盾的，这一点是毋庸置疑的，而我想变成的人便是这些关键词所形容的。起初之所以没有理解以上的关系，是因为没有好好的思考，也没有认真仔细的观察自己； 现在有一定的理解；这些关键词在字面意思上是的的确确是存在一定的矛盾的；但是人并不是一维的，人是多元的。**在生活中开朗，在做事中沉稳，在发言中自信，在放松中皮实！**如此一来，从我的角度来看，我感觉这个问题已经被透透彻彻的解决了； 换个角度看问题，的确是能收获意想不到的答案； 后记 ​ 总结还是很有用的，起初我一直拿着浪费时间，来给自己找理由推脱；但是显然发现：磨刀不误砍柴工。在整理的同时就是在给自己反思最近时间内的一些自己状况，停下来看看自己走的路是不是对的，看看接下来该往哪走，更甚者，稍微驻足停留稍偏歇息，也是为了接下来能够更好的全力以赴！大学时光，相比金钱更宝贵的是这四年黄金时间时光。哪怕纵观人生长河，如此四年显得如此耀眼；最后一最近很火的一篇论文致谢结束此篇文章吧； 理想并不伟大，只愿年过半百，归来认识少年！ ","date":"0001-01-01","objectID":"/posts/think/2021%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9A%8F%E7%AC%94/:0:1","tags":["think","gossip","life"],"title":"2021年4月18日 随笔】一些思考","uri":"/posts/think/2021%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9A%8F%E7%AC%94/"},{"categories":["think","gossip"],"content":"附：如何度过大学四年——这人生最宝贵的时光 (节选) 如何度过大学四年——这人生最宝贵的时光 (节选) 钱理群 一、大学时代：人生的盛夏 为什么说这是人生最宝贵的时光呢？根据我的经验，十六岁到二十六岁是人生的黄金岁月。十六岁以前什么都懵懵懂懂的，完全依赖于父母和老师，十六岁以后就开始独立了，二十六岁以后就开始考虑结婚啊、生孩子啊这么一大堆乱七八糟的事，真正属于自己的独立的时间就不多了。而这十六岁到二十六岁十年之间，大学四年又是最独立，最自由的。当然如果你想延长的话，你还可以考研究生，将这四年再延长一下。如何不虚度人生中这最自由的、最没有负担的、真正属于自己的四年的时间，是摆在每一个大学生面前的问题。 中学生和大学生最大的区别是：大学生是一个独立自主的个体，中学生是被动地受教育，而大学生是主动地受教育。当然在大学你还要听从老师的安排、听从课程的安排，那是国家教育对你们的要求。但是更重要的是要发挥自己的主动性，自由地设计和发展自己。有同学给我写信说我考上大学了，满怀希望进大学，结果一上课就觉得老师的课不怎么样，对老师不满意。我觉得其实每个大学都有一些不太好的老师，北大也一样！不可能所有课都是好的。中学老师不太好的话，会影响你的高考。但是在大学里，关键在你自己，时间是属于你的，空间是属于你的，你自己来掌握自己，自己来学习。不必像中学那样仅仅依赖老师，需要自己独立自主，自我设计。 那么这就产生了一个问题，大学是干什么的？你到大学来是为了完成什么任务？我在北京老看见那些老大妈在那里扭秧歌，扭得非常起劲。按说这时候不应该再扭秧歌，是因为她们在年轻的时候没有好好扭过秧歌，所以到老了就要扭秧歌，而且扭得非常投入、非常狂。现在是老年人狂，相反，少年却是少年老成。这就出了大问题。所以我经常对北大的学生讲：“你此时不狂更待何时？”这人生的季节是不能颠倒的。 进入大学就要三样东西：知识、友谊和爱情。爱情这东西可遇不可求，你不要为爱情而爱情，拼命求也不行。现在好多年轻人赶时髦，为时髦而求爱情是不行的。但遇到了千万不要放掉，这是我们过来人的教训。大学期间同学的友谊是最可珍贵的，因为这种友谊是超功利的、纯真的友谊，同学之间没有根本的利益冲突。说实在话，进入社会之后，那种朋友关系就多多少少有些变味了，多少有利益的考虑。你们可能体会不到，我们都是过来人，现在我们大学同学喜欢聚会就是回忆当年那种纯洁的、天真无邪的友谊。一生能够有这样的友谊是非常值得珍惜的。 二、“立人”之本：打好两个底子 你在大学里是学得专业知识技能，使自己成为合格的专业人才，以后一方面可以适应国家建设的需要，适应人才市场的需要，另一方面对个人和家庭来说也是谋生的手段。具体地说，你在大学时要考虑这样两个问题：一、人生的目的是什么？二、怎样处理人与人，人与社会，人与自然的关系？怎样在这几者之间建立起合理的、健全的关系？思考这样一些根本性的问题就是人文关怀。这样才会建立起自己的一种精神信念，以至于信仰，才能为你一辈子的安身立命奠定坚实的基础。这个问题大学期间解决不了，研究生阶段也一定要解决，因为这是安身立命的最基本的问题。同时要不断开拓自己的精神自由空间，陶冶自己的性情，锻炼自己的性格，发展自己的爱好，提高自己的精神境界，开掘和发展自己的想象力、审美力、思维能力和创造能力，使自己成为一个健全发展的人。大学的根本的任务不仅是传授专业知识，而且是“立人”。所以大学期间要打好两个底子。首先是专业基础的底子、终生学习的底子。第二个底子就是精神的底子，就是刚刚我提到的安身立命的人文关怀。 读什么书？读书的范围，这对同学们来说可能是更现实的、更具体的问题。鲁迅先生在这方面有非常精辟的见解：年轻人大可看本分以外的书，也就是课外的书。学理科的偏看看文学书，学文学的偏看看科学书，看看别人的研究究竟是怎么一回事。这样对于别人、别的事情可以有更深切的理解。 现在有些学者的精神气质、气度、精神修养上与前辈学者有距离，而这个距离不是临时努力读书能够弥补的。精神气质差异的根本的原因在于知识结构的不同，在于缺少文理交融的境界。在一般情况下，学理科的人缺少文学的修养，缺少哲学的修养显不出他有什么缺欠。反过来一般学文学的人不懂自然科学好像没有什么关系。但是到一定高度的时候，学理工的有没有文学修养和学文学的人有没有自然科学的修养就会显出高低了。知识结构的背后是一个人的精神境界的问题，而一个人能否成功最主要的是看他的精神境界。 那么在大学期间我们如何朝着这个方向去努力呢？怎样打基础呢？我有这有这样一个看法，提供给大家参考。我觉得大学期间的学习，应该从三个方面去做。 第一方面，所有的学生，作为一个现代知识分子，都必须学好几门最基础的课程。一个是语言，包括中文和外语，这是所有现代知识分子的基础。作为一个健全的现代中国知识分子，首先要精通本民族的语言，同时要通一门或者两门外文，不能偏废。在注意语言的同时，还有两门学科的修养值得注意。一个是哲学，哲学是科学的科学，哲学的思维对人很重要，无论你是学理的还是学文的,都要用哲学的思维考虑问题,有没有哲学思维是很重要的问题。还有一个是数学,数学和哲学都是最基础的学科，也同样关系着人的思维问题。当然，不同的专业对数学和哲学的要求不一样。 第二方面，必须打好自己专业基础知识的底子。我认为在专业学习上要注意两个要点。一个是要读经典著作。文化讲起来非常玄、非常复杂，其实都是从一些最基本的经典著作生发出来的。第二个要点是掌握专业学习的方法。通过具体学科、具体课程的学习，掌握住专业学习的方法。这样在专业方面，你既打了基础，有经典著作做底子，同时又掌握了方法，那么以后你就可以去不断深造了。 第三方面，要博览群书。要学陶渊明的经验——“好读书不求甚解”，用鲁迅的话说就是“随便翻翻”，开卷有益，不求甚解。在北大有无数的讲座，我鼓励我的学生都去听讲座，听多了你就不一样了。我们北大有个传统，听课的有一半的是旁听的。课堂上老师姑妄讲之，学生姑妄听之。你睡着了也不要紧，懵懵懂懂也听到了几句话，这几句话就能让你受益无穷。我们曾经开玩笑，也是北大人比较自豪的一点，说“我们的学生就是四年睡在寝室里不起床，他听也听够了。”因为那地方信息广泛，什么消息、什么人都有，听够了出去就可以吹牛。你不要看是北大学生就怕他，他虽然什么东西都知道一点，但其实大部分都是听来的。他虽然不求甚解，但他知道一点儿就比你高明。所以你们每个人底子打好了，然后就博览群书，知识有的是读来的，有的是听来的。人才是熏陶出来的，是不经意之间熏出来的，不是故意培养出来的。 三，沉潜十年：最诚恳的希望 现在的年轻人最大的毛病就是想把好事占全，样样都不肯损失。你要取得学习上的成功、研究上的成功，必须有大量的付出，时间、精力、体力、脑力，必须有所牺牲，少玩点甚至是少睡点觉，更没有时间来打扮自己。你打扮自己的时间多了，读书的时间就少了，这是一个非常简单的道理。怎么安排时间，我没有一个价值判断。你打扮自己、你整天玩，那也是一种人生追求，不能说读书一定就比玩好。不过你要想清楚，这边花得多那边就有损失，你打扮的时间、玩的时间多了，那就会影响读书。想多读书就不要过分想去玩、去打扮自己。这背后有一个如何处理物质和精神的关系问题，既要物质的充分满足又要精神的充分满足，那是一种理论的说法，是一种理想状态的说法，或者从整个社会发展的合理角度说的，落实到个人是比较难实现的。我认为落实到个人物质首先是第一的，所以鲁迅先生说：“一要生存，二要温饱，三要发展。”他说得很清楚，生存、温饱是物质方面的，发展是精神方面的。在物质生活没有基本保证之前是谈不上精神的发展的。过去我们有一种说法就是要安贫乐道，这是一种骗人的东西，千万不要上当。要你安贫乐道的人自己在那里挥霍，我们不能安贫，我们基本的物质要求要满足，要理直气壮地维护自己的物质利益。 “沉”就是沉静下来，“潜”就是潜入进去，潜到最深处，潜入生命的最深处，历史的最深处，学术的最深处。要沉潜，而且要十年，就是说要从长远的发展着眼，不要被一时一地的东西诱惑。我觉得很多大学生，包括北大的学生都面临很多诱惑。北大学生最大的问题就是诱惑太多，因为有北大的优势要赚钱非常容易。还有就是很容易受外界环境的影响，很多北大学生刚入学的时候非常兴奋，充满种种幻想。一年级的时候混混沌沌的，到了二三年级就觉得自己失去目标了，没意思了。看看周围同学不断有人去经商，去赚钱，羡慕得不得了。再看到有人玩得非常痛快，也羡慕得不得了，所以受环境的影响变得越来越懒惰。有的人非常热心地做社会工作，我不反对做社会工作，但有的人目的性极强，过早地把精力分散了，就无法沉下来，缺少长远的眼光，追求一时一地的成功。同学们要记住你现在是人生的准备阶段，还不是参与现实，还不是赚钱的时候。当然你做勤工俭学是必要的，也是应该提倡的，但是你不能在大学期间只忙于赚钱，要不然以后你会后悔的。因为你一生之中只有这四年是独立自由的，只有权利而没有义务的，赚钱以后有的时间赚，从政以后有的时间搞。这四年你不抓紧时间，不好好读书，受种种诱惑，图一时之利，放弃了长远的追求，底子打不好，以后是要吃大亏的，会悔之莫及。 在我们中国这个社会有三种人混得好。第一种人，家里有背景，他可以不好好读书。但他也有危险，当背景出了问题，就不行了。最后一切还得靠自己。第二种人，就是没有道德原则的人，为达到目的，无论红道、黑道还是黄道，他都干。但对于受过教育的人，毫无道德原则的什么事都干，应该是于心不甘的吧。第三种能站住的人就是有真本领的人，社会需要，公司需要，学校也需要。所以既没好爸爸，又有良心有自己道德底线的人，只有一条路——就是有真本事。真本事不是靠一时一地的混一混，而是要","date":"0001-01-01","objectID":"/posts/think/2021%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9A%8F%E7%AC%94/:1:0","tags":["think","gossip","life"],"title":"2021年4月18日 随笔】一些思考","uri":"/posts/think/2021%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9A%8F%E7%AC%94/"},{"categories":null,"content":"Spring 1.1、优点 ==控制反转（incersion of control) \u0026\u0026 依赖注入（dependency injection)== 解释：依赖注入是控制反转的附属品。正是由于控制反转才能够产生依赖注入的机会；Ioc不是一个技术，而是一个编程的思想方法。主要就是将对象的控制权给控制器（controller）,这里所说的控制，也就是如此。 下面是反转，反转与之相对的正传，正转就是传统意义上的对象主动的创建资源，自给自足，需要什么就自己创建什么；反转指的是：这种需要什么就去创建什么的能力被剥夺，而是由控制器掌握；如此便达到了：有曾经的主动创建变成了当下的被动接受，上方所说的依赖注入就是对象被动的接受依赖形象的描述； 好处：进一步解构代码 关系。更方便代码复用和测试 IoC和DI的关系： IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，**“****依赖注入”****明确描述了“被注入对象依赖IoC 容器配置依赖对象”。 Spring 核心的思想便是Ioc，在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。 支持事务处理，框架整合支持 轻量级的，非侵入式的 控制反转样例 import com.ymyguang.dao.UserDaoMysqlImpl; import com.ymyguang.dao.UserDaoOracleImpl; import com.ymyguang.service.UserService; import com.ymyguang.service.UserServiceImpl; /** * @another ymyguang * @date 7/22/2021 10:09 AM */ public class Mytest { public static void main(String[] args) { UserService userService = new UserServiceImpl(); //控制权交给用户 ((UserServiceImpl)userService).setUserDao(new UserDaoMysqlImpl()); userService.getUser(); } } 2、初探Spring XML文件配置 Spring的关键在于配置文件，在常规的Java代码中，创建一个对象需要一下格式： 类型名 变量名 = new 类型名，而在Spring当中，一切创建创建对象的操作，都可以由Bean来解决；同时还能向相关对象的属性，进行赋值；在Bean中，有以下格式： \u003cbean id = \"Hello\" class = \"com.ymyguang.pojo\" \u003e \u003cproperty name = \"str\" value(ref) = \"Hello\"/\u003e \u003c/bean\u003e 与正常创建对象格式相对应的是： id –\u003e 变量名称 class –\u003e 类型名 name –\u003e 字段名称 value –\u003e 基本数据类型 ref –\u003e Spring容器已经引入的成员 Test文件测试 一个核心的关键：就是首先要获取容器的上下文，之后就可以再次获取由容器创建的对象（这里的对象是单例，只有一个，因此数据也是共享的） import com.ymyguang.pojo.Hello; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @another ymyguang * @date 7/22/2021 11:44 AM */ public class Mytest { public static void main(String[] args) { //获取容器的上下文 ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); //获取所创建对象（容器创建），getBean中的字段就是Bean文件中的ID名称，实际上也就是创建的实例对象的变量名称 Hello hello = (Hello) context.getBean(\"hello\"); System.out.println(hello.toString()); System.out.println(hello.getHello()); 总结：到目前为止，Sping全局的接管了实例化对象的生命周期，其中包括创建，传递，销毁等等，在调整功能时，大大的简化了代码的修改，降低了各个对象之间的耦合性。==一个bean就是一个对象的实例化== 3、IOC创建对象的方式 一、无参数创建：实际上就是调用对应类的无参构造函数 二、有参数创建：同样是利用类的构造函数 下标创建 \u003cbean id=\"user\" class=\"com.ymyguang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"Liubiao\"/\u003e--\u003e \u003cconstructor-arg index=\"1\" value=\"2\"/\u003e--\u003e \u003c/bean\u003e 属性名创建 \u003cbean id=\"user\" class=\"com.ymyguang.pojo.User\"\u003e \u003cconstructor-arg name=\"age\" value=\"12\"/\u003e \u003cconstructor-arg name=\"name\" value=\"ymyguang\"/\u003e \u003c/bean\u003e 传入类型创建：字段：type ,有限制，不常用 总结：Spring载入Bean时，所有的对象都已经被创建。且多次返回的是同一个对象 4、Spring文件配置 import 导入其他Bean文件，通常在团队开发当中使用；格式如下 \u003cimport resource=\"Beans.xml\"/\u003e alias 别名 \u003calias name=\"user\" alias=\"userT\"/\u003e 5、依赖注入（Dependency Injection) 5.1、基本类型注入 （set注入） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"com.ymyguang.pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"北京\"/\u003e \u003c/bean\u003e \u003c--!--\u003eset注入\u003c/--!--\u003e \u003cbean id=\"student\" class=\"com.ymyguang.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"ymyguang\"/\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e三国演义\u003c/value\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003cproperty name=\"games\"\u003e \u003clist\u003e \u003cvalue\u003eLOL\u003c/value\u003e \u003cvalue\u003eCS\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003cproperty name=\"happy\"\u003e \u003cset\u003e \u003cvalue\u003e足球\u003c/value\u003e \u003cvalue\u003e篮球\u003c/value\u003e \u003cvalue\u003e棒球\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003cproperty name=\"id\"\u003e \u003cmap\u003e \u003centry key=\"身份证\" value=\"3131231313131\"/\u003e \u003centry key=\"IdCard\" value=\"dedeeededede\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003cproperty name=\"male\"\u003e \u003cnull/\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 规律：基本上就是，对应的数据类型由对应的标签了，其内容在当中； 5.2、构造器注入 \u003cbean id=\"user\" class=\"com.ymyguang.pojo.User\"\u003e \u003cconstructor-arg name=\"age\" value=\"12\"/\u003e \u003cconstructor-arg name=\"name\" value=\"ymyguang\"/\u003e \u003c/bean\u003e 5.3、拓展","date":"0001-01-01","objectID":"/posts/java/spring%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"Spring笔记","uri":"/posts/java/spring%E7%AC%94%E8%AE%B0/"},{"categories":["English","Note"],"content":"逻辑词代换 表示因果 表示原因 because=\u003e in that; bacause of=due to = be responsible for 表示结果： so = therefore = as a resule/consequence 表示对比 相似性的对比： likewise = similarly = equally = at the same time(同样地) 差异性对比： but = by contrast = alternatively 表示递进 beside = also = in addition = moreover = in other word ，另外 表示让步 In spite of = despite = though 尽管，虽然 of course = indeed = it is ture that..的确 there is no doubt that…. 毫无疑问的是…… it may be ture that…..或许真实的是 there is no denying that… 不可否认的是 In effect = indeed = virtually 实际上，事实上 表示条件 if = providing/supposing that 假如，如果 in case of = in the event of 万一。。。 表示目的 to = in order to = so as to 引出对象 about = concerning = in respect of 关于 in terms of 就。。。而论，在。。。方面 when it comes to…… 当提到…..时 表示强调 on the whole = all in all = come to the conclusion 总的来说 in short = in a word 简而言之 in any case = at any rate = anyway 无论如何 表示举例 like = such as = for instance = a good case in point is…….例如 ","date":"0001-01-01","objectID":"/posts/english/%E9%80%BB%E8%BE%91%E8%AF%8D%E4%BB%A3%E6%8D%A2/:0:1","tags":["English","Note"],"title":"逻辑词代换","uri":"/posts/english/%E9%80%BB%E8%BE%91%E8%AF%8D%E4%BB%A3%E6%8D%A2/"},{"categories":null,"content":"千梦：“我不知道，但是我也知道你不知道。” 可以排除5月和2月， 排除五月原因：因为5月只有一种可能，如果是五月，千梦就可以知道答案，但现实是千梦不知道，因此五月排除； 排除二月原因：在所有可能的日子中，只有二月中的10日存在一次，如果燕子拿到的是10，那么燕子就会知道答案了。但现实是燕子不知道，则不是二月； 燕子回答：“你说得对，我的确不知道。” 可以排除日期为2的日子，也就是9月2日 **排除2日的原因：**当二月排除以后，燕子还是不知道，观察二月份日子，发现二月二号与九月二号有相同的日子，但是现实是燕子不知道，因此不会是2号结尾的日期 千梦接着说：“嗯，即使现在，我仍然不知道。” 可以排除9月 **排除9月的原因：**当燕子说完不知道以后，9月就只剩下一个日子，但是千梦仍然是不知道，因此可以排除9月份 燕子回答:“是的，我也仍然不知道。” 排除1日的原因 **排除1日的原因：**当九月被除掉以后，只有三月份中的1号，为单独日子，如果是1号的话，燕子就可以得出答案，但是还是没有得出，因此可以排除1日 千梦又回答道：“真糟糕，我还是不知道。” 可以排除三月 可以排除三月：通过上方排除的1号之后，3月就只剩一个3月14日，但是千梦还是能确定生日日期，就意味着不会是三月，故三月排除 燕子笑了笑说：“别急，我现在知道了。” 可以确定7月14日 **可以确定7月14日原因：**进行到这里的时候还剩下如下日期： 但是此时，燕子就可以确定日期了，则意味着该日期一定是唯一的，观察剩下的日期，只有7月14日的日子独立，因此便可以确定教授的生日就是7月14日 ","date":"0001-01-01","objectID":"/posts/math/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A2%98%E7%9B%AE/:0:0","tags":["other"],"title":"一个有趣的逻辑推理题","uri":"/posts/math/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A2%98%E7%9B%AE/"}]