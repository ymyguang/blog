---
title: "排序算法"
draft: false
date: 2020-06-29T15:05:22+08:00
tags: ["coding", "basic","algorithm"]
categories: ["coding","algorithm"]
---

## 算法中的几种排序

### **前言**

尽管现在的各种库很丰富，但是还是有必要学习一些经典的算法，去学习思想。

#### 1.冒泡排序（On^2）

这是最简单的一种排序方法。排序名称很形象。冒泡：越来越大。即每轮循环，把最值传递到指定的位置。就像a>b,b>c，所以a最大。

排序的算法就是：两两比较，得到最值，继而接着向后传递 。直到到达指定位置。至此一轮循环的任务结束。比如说把最大值放在后面（升序），那么就是在一轮的循环种中，每次两两比较，都把大的向后交换，最终大的就会在数组的最后面。**值得注意的是：**当筛选出列表中最大值后 ，下一次循环就无需再去比较最后的值。依次类推；

基本思路步骤如下：

```cpp
for (int i = 0; i < a.length();i++) // 循环次数
	for (int j = 0; j < a.length - i;j++)  //比较元素位数
		if(a[j]>a[j+1])
			swap(a[j],a[j+1])
```

#### 2.选择排序（On^2）

选择排序跟冒泡排序比较相似。

**基本思路**：每轮循环取最大的值（或者是最小的值）通过标记坐标的方式，记录最值。循环结束后与

列表首（尾）进行交换；每次循环结束后，所比对的元素少一；

**基本步骤**

```python
for (int i = 0;i < a.length();i++)
	max = 0; //从首元素开始比对
	for (int j = 0; j < a.length.() - i; j++)
		if (a[j] > a[max])
			max = j;
	if (i != max)
		swap(a[max],a[i.length() - i]);
```

#### 3.插入排序（On^2）

这个排序方式也很形象。算法实现过程类似打扑克牌时的排序。

**基本思路：假设前面的数列顺序是正确的。**先记录自己的值（可以想象成挖坑了），通过和自己前面的数字进行比较，如果前面的数字大于该数字，就将前面的数字向后移动一位（也就是把自己的坑填上；就这样一直比对一直填坑。直到找到前面比自己小的数字，再把该数字放到该数字的后面；

**基本步骤**

```cpp
for (int i = 1; i < a.length(); i++){
		X = a[i];
		j = i - 1;
		while (a[j] > X && j >= 0){
			a[j+1] = a[j];
			j--;
		}
		a[j+1] = X;
}
```

#### **4.归并排序**

相比上面三个排序来讲，下面的排序显得更有分量。因此可以在这里学到更多的思想。

归并排序有一个很重要很重要的思想：**分治法！**

何为分治法：分而治之。大任务拆解成小任务解决。当每个小任务都解决了，大任务也就迎刃而解了。

其次，**二分法**是归并排序中所用的“拆解方式”。执行逻辑就是：把大数组分解分解再分解，知道分解到只有两个元素的时候 ，再将两个元素排序，排序完成后，在进行合并。每次合并都是比对子数组第一元素。

**基本步骤：**

```cpp
// 分函数
Merge(int l,int r,int arr[]) {
	int	mid = (l+r)/2;
	 if (l < r) {
	 	Merge(l, mid, arr);
	 	Merge(mid+1, r, arr);
	 	Sort(l, r , mid ,arr);
	 }
}
// 本函数采用了递归的方式。首先是左半部分的元素进行拆分，此时函数 重新进入Merge函数，知道l=r（是剩下一个元素）。再去执行下面的Merge函数。此时mid是上一个函数的mid，r也是上一个函数的r.从而保证了左右两组数组的对称性。
// 最巧妙的地方就在于通过先入后出的方式实现了对数组的拆分，这里值得玩味，很巧妙；
```

```cpp
//合函数
Sort(int l,int r,int mid, int arr[]) {
    // 说明：都取首地址的作用是比较数组元素
    int i, j, index;
    int t[Max] = {0}; //临时数组
    i = l;			  //其中一个数组的首地址
    j = mid + 1;	  //另外一个数组的首地址
    index = 0;	      //临时数组的首地址

    while (index <= r - l){// 需要比对数字个数，也是比对的次数
    	while(i <= mid && j <= r) { // 两个数组内都含有元素时，谁大把谁放到临时数组内；
			if (arr[i] < arr[j]) {
                t[index++] = arr[i++];
            }
            else
                t[index++] = arr[j++];
        }
        if (i == mid + 1)  // 当一个数组内没有元素的时候 ，就将另一个数组内的元素拷贝到临时数组中（循序一致）
            t[index++] = arr[j++];
        else
            t[index++] = arr[i++];
    }
	for (int i = l; k = 0 ; k <= r-l; k++) {  //把临时数组中的元素填充到无需的数组中，使之有序。
        arr[i] = t[k];
    }
}
```

**PS值得注意的是：归并排序逻辑上是把数组分成子数组。但是考虑到资源的宝贵以及运算速度，在实际上，直接通过传递和读取数组的一定范围的索引编号，来实现分开数组的目的。**

#### 5.快速排序（Onlogn）

目前所有排序中，快速排序是速度最快的排序方式，他与归并排序类似，也是利用到了二分思想（注意：二分不是仅仅对半分，而是分两份）。这种排序算法也很奇妙。

快排难的不是思路，难的是确定边界调节（何时跳出函数）

**基本思路：** 

1. 选中一个数组元素为基准，遍历整个数组，把大于该数字的元素放到一侧，小于该数字的元素放到另一侧。在这个过程中，实现了遍历一次数组就能完成。思路也是非常的巧妙。(整个数组整体上被分成了，一半是大于某数字的，一半是小于某数字的。此时就已经初步实现了数组的有序性。)

2. 在再已经大体上有序的左侧数组选中一个基数，重复步骤一

3. 数组右侧重复 步骤一

4. 当右边界小于左边界时，退出循环


**基本步骤**

```cpp
QuickSort(int l, int r, int a) {
    if (l > r) // 边界条件
        return 0;
	int i = l;
	int j = r;
	int X = a[l];	// 记录主值
	while (i != j){
	while (a[j] >= X && i < j)j++;  // 右指针移动
	while (a[i] <= X && i < j)i++;	// 左指针移动
	//交换数字
    int t = a[i];	
	a[i] = a[j];
	a[j] = t;
	}
    // 主值置位
	a[l] = a[i];	
	a[i] = X;
    QuickSort(l, i - 1, a);
    QuickSort(i + 1, r, a);
} 
```

**Q：为什么右指针先移动，而不是左指针先移动？**

**A：只有先移动右指针才能保证，当两指针相遇时，所值数字小于主值。从而达到了左边都是小于该数字的目的。**



### **后记**

当然除了以上所说的排序方式之外，还有一些其他的排序方式。例如桶排序，猴子排序（狗头），睡眠排序，等等等等。相信在以后会有更优秀的排序方式诞生。目前来讲，没有绝对好的排序方式，只有根据排序基数大小，数列自然顺序有关系，因此只有结合数据的实际情况才能找到最好的排序方式。