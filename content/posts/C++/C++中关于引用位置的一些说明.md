## C++中关于引用位置的一些说明

##### 引用的基本概念：引用实际上就是一个变量的别名。也仅仅是一个变量的别名。

~~当定义一个引用时，甚至没有创建任何新的变量？（存疑）~~。在底层上。是有将被引用变量的地址放到引用变量所在地址中的操作。换句话说：创建引用变量在底层是由相关的操作的。但是由于编译器的优化，所显现出来的现象就是：引用变量的内存地址和被引用变量的内存地址是一致的。（其实在物理层面并不是相同的，不是向宏定义那样，在预处理阶段就完成替换）另外，int a = 1；所谓的在内存中申请一个叫做A的内存空间这种说法 也是不准确的。实际上是由编译器将二进制的1放到以A为地址的内存中去；

新定义的变量完全可以当作之前的变量使用。甚至引用变量的内存地址都与被引用的变量地址相同。因此直接编辑新的变量和直接操作原始变量没有任何区别

但是引用变量的在赋值符号（=）的左右位置有着不同的意义和使用方法。

当引用变量在**左边**时，即：

```cpp
int number = 2;
int &refVal = number;
refVal = 222; // 等价于：number = 222;
```

以上是很记住的，也比较容易理解。无非就是修改原始变量；

---

当引用变量在**右边**时,即

```cpp
int number = 2;
int &refVal = number;
int x = 0;
x = refVal;
// 这里的refVal实际上也就等同于number的存在，这条语句就是一个简单的赋值
```

---

其实在原理上肯定有相关的原因（这就是可以所问的问题）所涉及到的知识就是：C语言在内存的分配情况