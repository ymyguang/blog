---
title: "C/C++编译过程"
date: 2020-05-09T15:05:22+08:00
draft: false
tags: ["coding", "C/C++","Tip"]
categories: ["coding","C/C++"]
---

#### C/C++编译过程

在学习C++过程中，遇到了头文件为什么最好是包含.h类型，而不是cpp类型的问题。在寻找结果的过程过，发现是跟语言的编译过程有关，借此机会学习一下C/C++的编译过程

目的就是：将高级语言转换成二进制语言，供计算机执行；

### 

---

### 2021年2月24日更新

### C语言运算规则

语句运算顺序：符号优先级，结合方向

- 算术运算符结合方向：从左往右
- 赋值运算符结合方向：从右往左
- 逗号的值是最后的的值：左结合

运算之后的数据类型，当运算变量数据类型不符是，类型低的自动转换成内存占用高的，（强数据转换），在C中的强数据转换采取：舍去原则；强数据转换是中间值，不印象原来的数据

```
    int/int -> int
    int/float ->float
    %的操作数是整数，符号和被除数一致
   // 所有单位运算都是从右往左算的
```



### C程序的调试过程

- 编辑    .cpp ,c 源程序文件
- 编译    .obj      目标文件
- 链接   .exe     可执行文件
- 执行

------

### 2020年6月28日更新

前几天我尝试在vs code中，编写多文件的代码文件，但是出现了很多报错情况，经过排查发现，vsc在没有build system的情况下只会编译当前文件，这就导致了多文件没办法被编译，所以当只有这一个编译好的程序文件去尝试连接代码中不存在的变量时，肯定是找到不到的，就爆出了错误。

那么如何去解决在vsc多文件编译的情况？方法是：上文提到的build system（构建系统），目前流行的时：cmark，它可以根据编写规则，生成makefile，之后在去按照makefile去批量编辑多个文件，如此一来，第四阶段的链接才能生效。

多说一句，现在很多都是IDE解决一切，什么都不管直接小三角号，一个三角号就一劳永逸了，时间长了根本无法了解编译的过程，因为所有的东西都被IDE给办了，自己什么都不知道！编程而言，不应该仅仅在表面上 ，还要知道背后的原理，这样才能更容易理解新东西！



# 过程

#### 1.预处理

替换代码中的头文件，宏定义，去除代码注释

```cpp
gcc -E text.cpp -o text.i   -E：预处理完成后终止编译进行
```

#### 2.编译

此过程中会将预处理之后的代码，翻译特定的汇编代码，通常情况下，当编译器报错语法错误时，就是在这个过程中。

```
gcc -S text.cpp -o text.i   -S：编译完成后终止编译进行
```

#### 3.汇编

显而易见，就是把上一步转换到的汇编代码，翻译成机器语言

```
gcc -c text.cpp -o text.o   -c：汇编完成后终止编译进行
```

### 4.链接

在C/C++中，一定少不了对头文件的引用，当编译器把自己的cpp编译以后，还会链接到cpp中的头文件所对应的,obj文件，如此以来，整个程序才被编译成了可执行文件。

附表：

| 文件扩展名    | 文件类型                   |
| :------------ | -------------------------- |
| .c            | C语言代码                  |
| .C、.cc、.cpp | C++语言代码                |
| .i            | 预处理后的C语言代码        |
| .s、.S        | 汇编语言代码               |
| .o            | 目标代码                   |
| .a            | 静态链接库(程序编译时使用) |
| .so           | 动态链接库(程序运行时使用  |



回到上面的问题：

**Q：为什么最好是包含.h类型，而不是cpp类型的问题?**

**A：当我们的头文件是cpp文件时，有如下弊端：**

- 当代码文件进行修改后，整个项目都需要重新编译，而当头文件是.h的时候，尽管修改了源代码，但是编译的还是那些代码量，不会在对头文件进行重新编译，之后直接就将编译出来的obj文件，与头文件对应的lib文件进行结合即可。（当整个项目不是很大的时候，二者没有太大的区别，但是当项目大时，这种优势就会很明显了）
- 当以.h为头文件时，我们就可以很容易的实现库的传播，又能保证代码的闭源。



**include <**.cpp>   对\*\*\*.cpp文件重新编译，之后将二者连接 。**

**#include<***.h>   对.h对应的文件名实现连接。**



### 再理解：

C/C++编译方式是：单元翻译，独立的编译每一个cpp文件，例如a.cpp，b.cpp在同一个项目文件中，因此在编译整个项目的过程中，编译器会独立的编译a.cpp，b.cpp。但是当b.cpp中，，有一个a中的函数，直接引用了a中的函数，此时编译器会不会报错？实际上是不会报错的，只要我们在b.cpp内声明了这个函数，编译器在编译b.cpp的时候，就会生成一个符号表（symbol table）【b中看不见的变量/函数/类等都会存放到这个表格内】，此时编译器在编译完成后，在链接的阶段就会按照符号表中的值对整个项目进行查找。从而实现了源码分离。

```
通常，在一个 C++ 程序中，只包含两类文件—— .cpp 文件和 .h 文件。其中，.cpp 文件被称作 C++ 源文件，里面放的都是 C++ 的源代码；而 .h 文件则被称作 C++ 头文件，里面放的也是 C++ 的源代码。

C++ 语言支持"分别编译"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件 a.cpp 中定义了一个全局函数 "void a(){}"，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件 b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。

这是怎么实现的呢？从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 "void a()" 函数之前，先声明一下这个函数 "voida();"，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 "void a()" 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。

注意这里提到了两个概念，一个是"定义"，一个是"声明"。简单地说，"定义"就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而"声明"则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。定义的时候要按 C++ 语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？
这种机制给 C++ 程序员们带来了很多好处，同时也引出了一种编写程序的方法。考虑一下，如果有一个很常用的函数 "void f() {}"，在整个程序中的许多 .cpp 文件中都会被调用，那么，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。一个函数还好对付，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？能保证每个程序员都可以完完全全地把所有函数的形式都准确地记下来并写出来吗？
```

贴一下链接：https://www.runoob.com/w3cnote/cpp-header.html

讲的很清楚！！！

参考链接：

[编译器的工作过程](http://www.ruanyifeng.com/blog/2014/11/compiler.html)

[C语言编译过程详解](https://www.cnblogs.com/CarpenterLee/p/5994681.html)

[C/C++程序编译过程详解](https://www.cnblogs.com/mickole/articles/3659112.html)